[
  {
    "id": 2,
    "title": "Two Sum",
    "category": "arrays",
    "difficulty": "easy",
    "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Return the answer in any order.",
    "functionSignature": {
      "javascript": "function twoSum(nums, target) {\n  // your code here\n}",
      "python": "def two_sum(nums, target):\n    # your code here\n    pass",
      "java": "public int[] twoSum(int[] nums, int target) {\n    // your code here\n    return new int[2];\n}",
      "cpp": "vector<int> twoSum(vector<int>& nums, int target) {\n    // your code here\n    return {};\n}"
    },
    "testCases": [
      { "input": "[2,7,11,15]\n9", "expectedOutputs": ["[0,1]"] },
      { "input": "[3,2,4]\n6", "expectedOutputs": ["[1,2]"] },
      { "input": "[3,3]\n6", "expectedOutputs": ["[0,1]"] },
      { "input": "[1,2,3,4]\n5", "expectedOutputs": ["[0,3]", "[1,2]"] },
      { "input": "[0,4,3,0]\n0", "expectedOutputs": ["[0,3]", "[3,0]"] },
      { "input": "[1,1,1,1,2]\n3", "expectedOutputs": ["[3,4]", "[2,4]", "[1,4]", "[0,4]"] },
      { "input": "[0,0,0,1,5]\n6", "expectedOutputs": ["[3,4]"] },
      { "input": "[1,2,5,6,10]\n15", "expectedOutputs": ["[3,4]", "[2,4]"] },
      { "input": "[2,5,5,11]\n10", "expectedOutputs": ["[1,2]"] },
      { "input": "[1,2]\n3", "expectedOutputs": ["[0,1]"] }
    ]
  },
  {
    "id": 3,
    "title": "Add Two Numbers",
    "category": "linked list",
    "difficulty": "medium",
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.",
    "functionSignature": {
        "javascript": "function addTwoNumbers(l1, l2) {\n  // your code here\n}",
        "python": "def add_two_numbers(l1, l2):\n    # your code here\n    pass",
        "java": "public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    // your code here\n    return null;\n}",
        "cpp": "ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n    // your code here\n    return nullptr;\n}"
    },
    "testCases": [
        { "input": "[2,4,3]\n[5,6,4]", "expectedOutputs": ["[7,0,8]"] },
        { "input": "[0]\n[0]", "expectedOutputs": ["[0]"] },
        { "input": "[9,9,9,9,9,9,9]\n[9,9,9,9]", "expectedOutputs": ["[8,9,9,9,0,0,0,1]"] },
        { "input": "[1]\n[9,9,9]", "expectedOutputs": ["[0,0,0,1]"] },
        { "input": "[9]\n[1]", "expectedOutputs": ["[0,1]"] },
        { "input": "[1,8]\n[0]", "expectedOutputs": ["[1,8]"] },
        { "input": "[5]\n[5]", "expectedOutputs": ["[0,1]"] },
        { "input": "[2,4]\n[5,6,4]", "expectedOutputs": ["[7,0,5]"] },
        { "input": "[0,1]\n[0,1,2]", "expectedOutputs": ["[0,2,2]"] },
        { "input": "[1,2,3]\n[0,0,0]", "expectedOutputs": ["[1,2,3]"] }
    ]
    },
    {
  "id": 4,
  "title": "Binary Tree Inorder Traversal",
  "category": "binary tree",
  "difficulty": "medium",
  "description": "Given the root of a binary tree, return the inorder traversal of its nodes' values.",
  "functionSignature": {
    "javascript": "function inorderTraversal(root) {\n  // your code here\n}",
    "python": "def inorder_traversal(root):\n    # your code here\n    pass",
    "java": "public List<Integer> inorderTraversal(TreeNode root) {\n    // your code here\n    return new ArrayList<>();\n}",
    "cpp": "vector<int> inorderTraversal(TreeNode* root) {\n    // your code here\n    return {};\n}"
  },
  "testCases": [
    { "input": "[1,null,2,3]", "expectedOutputs": ["[1,3,2]"] },
    { "input": "[]", "expectedOutputs": ["[]"] },
    { "input": "[1]", "expectedOutputs": ["[1]"] },
    { "input": "[1,2]", "expectedOutputs": ["[2,1]"] },
    { "input": "[1,null,2]", "expectedOutputs": ["[1,2]"] },
    { "input": "[3,1,4,null,2]", "expectedOutputs": ["[1,2,3,4]"] },
    { "input": "[5,3,6,2,4]", "expectedOutputs": ["[2,3,4,5,6]"] },
    { "input": "[2,null,3,null,4,null,5]", "expectedOutputs": ["[2,3,4,5]"] },
    { "input": "[5,1,6,null,null,null,8]", "expectedOutputs": ["[1,5,6,8]"] },
    { "input": "[1,2,3,4,5]", "expectedOutputs": ["[4,2,5,1,3]"] }
  ]
},
{
  "id": 5,
  "title": "Number of Connected Components in an Undirected Graph",
  "category": "graph",
  "difficulty": "medium",
  "description": "You have a graph of `n` nodes. You are given an integer `n` and an array `edges` where `edges[i] = [a_i, b_i]` indicates that there is an edge between a_i and b_i. Return the number of connected components in the graph.",
  "functionSignature": {
    "javascript": "function countComponents(n, edges) {\n  // your code here\n}",
    "python": "def count_components(n, edges):\n    # your code here\n    pass",
    "java": "public int countComponents(int n, int[][] edges) {\n    // your code here\n    return 0;\n}",
    "cpp": "int countComponents(int n, vector<vector<int>>& edges) {\n    // your code here\n    return 0;\n}"
  },
  "testCases": [
    { "input": "5\n[[0,1],[1,2],[3,4]]", "expectedOutputs": ["2"] },
    { "input": "5\n[[0,1],[1,2],[2,3],[3,4]]", "expectedOutputs": ["1"] },
    { "input": "4\n[[2,3],[1,2],[1,3]]", "expectedOutputs": ["2"] },
    { "input": "2\n[]", "expectedOutputs": ["2"] },
    { "input": "3\n[[0,1],[1,2]]", "expectedOutputs": ["1"] },
    { "input": "4\n[[0,1],[2,3]]", "expectedOutputs": ["2"] },
    { "input": "6\n[[0,1],[2,3],[4,5]]", "expectedOutputs": ["3"] },
    { "input": "1\n[]", "expectedOutputs": ["1"] },
    { "input": "3\n[[0,1],[0,2]]", "expectedOutputs": ["1"] },
    { "input": "4\n[[0,1]]", "expectedOutputs": ["3"] }
  ]
},
  {
    "id": 6,
    "title": "Best Time to Buy and Sell Stock",
    "category": "arrays",
    "difficulty": "easy",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "functionSignature": {
      "javascript": "function maxProfit(prices) {\n  // your code here\n}",
      "python": "def max_profit(prices):\n    # your code here\n    pass",
      "java": "public int maxProfit(int[] prices) {\n    // your code here\n    return 0;\n}",
      "cpp": "int maxProfit(vector<int>& prices) {\n    // your code here\n    return 0;\n}"
    },
    "testCases": [
      { "input": "[7,1,5,3,6,4]", "expectedOutputs": ["5"] },
      { "input": "[7,6,4,3,1]", "expectedOutputs": ["0"] },
      { "input": "[1,2]", "expectedOutputs": ["1"] },
      { "input": "[2,4,1]", "expectedOutputs": ["2"] },
      { "input": "[3,2,6,5,0,3]", "expectedOutputs": ["4"] },
      { "input": "[1]", "expectedOutputs": ["0"] },
      { "input": "[]", "expectedOutputs": ["0"] },
      { "input": "[2,1,2,1,0,1,2]", "expectedOutputs": ["2"] },
      { "input": "[1,4,2,11]", "expectedOutputs": ["10"] },
      { "input": "[5,4,3,2,1]", "expectedOutputs": ["0"] }
    ]
  },
  {
    "id": 7,
    "title": "Reverse Linked List",
    "category": "linked list",
    "difficulty": "easy",
    "description": "Given the head of a singly linked list, reverse the list, and return the reversed list.",
    "functionSignature": {
      "javascript": "function reverseList(head) {\n  // your code here\n}",
      "python": "def reverse_list(head):\n    # your code here\n    pass",
      "java": "public ListNode reverseList(ListNode head) {\n    // your code here\n    return null;\n}",
      "cpp": "ListNode* reverseList(ListNode* head) {\n    // your code here\n    return nullptr;\n}"
    },
    "testCases": [
      { "input": "[1,2,3,4,5]", "expectedOutputs": ["[5,4,3,2,1]"] },
      { "input": "[1,2]", "expectedOutputs": ["[2,1]"] },
      { "input": "[]", "expectedOutputs": ["[]"] },
      { "input": "[1]", "expectedOutputs": ["[1]"] },
      { "input": "[1,2,3]", "expectedOutputs": ["[3,2,1]"] },
      { "input": "[1,1,2]", "expectedOutputs": ["[2,1,1]"] },
      { "input": "[2,3,4,5]", "expectedOutputs": ["[5,4,3,2]"] },
      { "input": "[10,20]", "expectedOutputs": ["[20,10]"] },
      { "input": "[7]", "expectedOutputs": ["[7]"] },
      { "input": "[5,4,3,2,1]", "expectedOutputs": ["[1,2,3,4,5]"] }
    ]
  },
  {
    "id": 8,
    "title": "Symmetric Tree",
    "category": "binary tree",
    "difficulty": "easy",
    "description": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).",
    "functionSignature": {
      "javascript": "function isSymmetric(root) {\n  // your code here\n}",
      "python": "def is_symmetric(root):\n    # your code here\n    pass",
      "java": "public boolean isSymmetric(TreeNode root) {\n    // your code here\n    return false;\n}",
      "cpp": "bool isSymmetric(TreeNode* root) {\n    // your code here\n    return false;\n}"
    },
    "testCases": [
      { "input": "[1,2,2,3,4,4,3]", "expectedOutputs": ["true"] },
      { "input": "[1,2,2,null,3,null,3]", "expectedOutputs": ["false"] },
      { "input": "[]", "expectedOutputs": ["true"] },
      { "input": "[1]", "expectedOutputs": ["true"] },
      { "input": "[1,2,2,null,3,3]", "expectedOutputs": ["false"] },
      { "input": "[1,2,2,2,null,2]", "expectedOutputs": ["false"] },
      { "input": "[1,2,2,3,null,null,3]", "expectedOutputs": ["true"] },
      { "input": "[1,null,2]", "expectedOutputs": ["false"] },
      { "input": "[1,2,2,3,4,4,3,5]", "expectedOutputs": ["false"] },
      { "input": "[1,2,2,null,3,3,null]", "expectedOutputs": ["true"] }
    ]
  },
{
  "id": 9,
  "title": "Contains Duplicate",
  "category": "arrays",
  "difficulty": "easy",
  "description": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.",
  "functionSignature": {
    "javascript": "function containsDuplicate(nums) {\n  // your code here\n}",
    "python": "def contains_duplicate(nums):\n    # your code here\n    pass",
    "java": "public boolean containsDuplicate(int[] nums) {\n    // your code here\n    return false;\n}",
    "cpp": "bool containsDuplicate(vector<int>& nums) {\n    // your code here\n    return false;\n}"
  },
  "testCases": [
    { "input": "[1,2,3,1]", "expectedOutputs": ["true"] },
    { "input": "[1,2,3,4]", "expectedOutputs": ["false"] },
    { "input": "[1,1,1,3,3,4,3,2,4,2]", "expectedOutputs": ["true"] },
    { "input": "[]", "expectedOutputs": ["false"] },
    { "input": "[0]", "expectedOutputs": ["false"] },
    { "input": "[1,2,3,4,5,6,7,8,9,1]", "expectedOutputs": ["true"] },
    { "input": "[1,2,3,4,5]", "expectedOutputs": ["false"] },
    { "input": "[2,14,18,22,22]", "expectedOutputs": ["true"] },
    { "input": "[99]", "expectedOutputs": ["false"] },
    { "input": "[1,2,3,4,4]", "expectedOutputs": ["true"] }
  ]
},
{
  "id": 10,
  "title": "Merge Two Sorted Lists",
  "category": "linked list",
  "difficulty": "easy",
  "description": "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.",
  "functionSignature": {
    "javascript": "function mergeTwoLists(list1, list2) {\n  // your code here\n}",
    "python": "def merge_two_lists(list1, list2):\n    # your code here\n    pass",
    "java": "public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n    // your code here\n    return null;\n}",
    "cpp": "ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n    // your code here\n    return nullptr;\n}"
  },
  "testCases": [
    { "input": "[1,2,4]\n[1,3,4]", "expectedOutputs": ["[1,1,2,3,4,4]"] },
    { "input": "[]\n[]", "expectedOutputs": ["[]"] },
    { "input": "[]\n[0]", "expectedOutputs": ["[0]"] },
    { "input": "[5]\n[1,2,3]", "expectedOutputs": ["[1,2,3,5]"] },
    { "input": "[2,6,7]\n[1,3,5]", "expectedOutputs": ["[1,2,3,5,6,7]"] },
    { "input": "[1]\n[1]", "expectedOutputs": ["[1,1]"] },
    { "input": "[1,2,4]\n[]", "expectedOutputs": ["[1,2,4]"] },
    { "input": "[1,3,5,7]\n[2,4,6,8]", "expectedOutputs": ["[1,2,3,4,5,6,7,8]"] },
    { "input": "[0,2,4]\n[1,3,5]", "expectedOutputs": ["[0,1,2,3,4,5]"] },
    { "input": "[5,10]\n[2,4,6]", "expectedOutputs": ["[2,4,5,6,10]"] }
  ]
},
{
  "id": 11,
  "title": "Validate Binary Search Tree",
  "category": "binary tree",
  "difficulty": "medium",
  "description": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).",
  "functionSignature": {
    "javascript": "function isValidBST(root) {\n  // your code here\n}",
    "python": "def is_valid_bst(root):\n    # your code here\n    pass",
    "java": "public boolean isValidBST(TreeNode root) {\n    // your code here\n    return false;\n}",
    "cpp": "bool isValidBST(TreeNode* root) {\n    // your code here\n    return false;\n}"
  },
  "testCases": [
    { "input": "[2,1,3]", "expectedOutputs": ["true"] },
    { "input": "[5,1,4,null,null,3,6]", "expectedOutputs": ["false"] },
    { "input": "[1,1]", "expectedOutputs": ["false"] },
    { "input": "[]", "expectedOutputs": ["true"] },
    { "input": "[10,5,15,null,null,6,20]", "expectedOutputs": ["false"] },
    { "input": "[2,1,4,null,null,3,5]", "expectedOutputs": ["true"] },
    { "input": "[3,1,5,null,2]", "expectedOutputs": ["true"] },
    { "input": "[3,1,5,0,2,4,6]", "expectedOutputs": ["true"] },
    { "input": "[2,null,1]", "expectedOutputs": ["false"] },
    { "input": "[1,null,2,null,3]", "expectedOutputs": ["true"] }
  ]
},
{
  "id": 12,
  "title": "Clone Graph",
  "category": "graph",
  "difficulty": "medium",
  "description": "Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node contains a value and a list of its neighbors.",
  "functionSignature": {
    "javascript": "function cloneGraph(node) {\n  // your code here\n}",
    "python": "def clone_graph(node):\n    # your code here\n    pass",
    "java": "public Node cloneGraph(Node node) {\n    // your code here\n    return null;\n}",
    "cpp": "Node* cloneGraph(Node* node) {\n    // your code here\n    return nullptr;\n}"
  },
  "testCases": [
    { "input": "[[2,4],[1,3],[2,4],[1,3]]", "expectedOutputs": ["[[2,4],[1,3],[2,4],[1,3]]"] },
    { "input": "[]", "expectedOutputs": ["[]"] },
    { "input": "[[2],[1]]", "expectedOutputs": ["[[2],[1]]"] },
    { "input": "[[2,3,4],[1,3,4],[1,2,4],[1,2,3]]", "expectedOutputs": ["[[2,3,4],[1,3,4],[1,2,4],[1,2,3]]"] },
    { "input": "[[2,3],[1,3],[1,2]]", "expectedOutputs": ["[[2,3],[1,3],[1,2]]"] },
    { "input": "[[2,3],[1],[1]]", "expectedOutputs": ["[[2,3],[1],[1]]"] },
    { "input": "[[2],[1]]", "expectedOutputs": ["[[2],[1]]"] },
    { "input": "[[2],[1,3],[2]]", "expectedOutputs": ["[[2],[1,3],[2]]"] },
    { "input": "[[2,4],[1,3],[2,4],[1,3]]", "expectedOutputs": ["[[2,4],[1,3],[2,4],[1,3]]"] },
    { "input": "[[2],[1]]", "expectedOutputs": ["[[2],[1]]"] }
  ]
},
{
  "id": 13,
  "title": "Detect Cycle in Linked List",
  "category": "linked list",
  "difficulty": "medium",
  "description": "Given the head of a linked list, determine if the linked list has a cycle in it. Return true if there is a cycle, otherwise false.",
  "functionSignature": {
    "javascript": "function hasCycle(head) {\n  // your code here\n}",
    "python": "def has_cycle(head):\n    # your code here\n    pass",
    "java": "public boolean hasCycle(ListNode head) {\n    // your code here\n    return false;\n}",
    "cpp": "bool hasCycle(ListNode* head) {\n    // your code here\n    return false;\n}"
  },
  "testCases": [
    { "input": "[3,2,0,-4]", "expectedOutputs": ["true"] },
    { "input": "[1,2]", "expectedOutputs": ["true"] },
    { "input": "[1]", "expectedOutputs": ["false"] },
    { "input": "[]", "expectedOutputs": ["false"] },
    { "input": "[1,2,3,4,5]", "expectedOutputs": ["false"] },
    { "input": "[1,2,3,4,2]", "expectedOutputs": ["true"] },
    { "input": "[1,2,3,4,0]", "expectedOutputs": ["true"] },
    { "input": "[1]", "expectedOutputs": ["false"] },
    { "input": "[1,2,1]", "expectedOutputs": ["true"] },
    { "input": "[1,2,3]", "expectedOutputs": ["false"] }
  ]
},
{
  "id": 14,
  "title": "Number of Provinces",
  "category": "graph",
  "difficulty": "medium",
  "description": "There are n cities. Some of them are connected, while some are not. A province is a group of directly or indirectly connected cities. Return the number of provinces.",
  "functionSignature": {
    "javascript": "function findCircleNum(isConnected) {\n  // your code here\n}",
    "python": "def find_circle_num(is_connected):\n    # your code here\n    pass",
    "java": "public int findCircleNum(int[][] isConnected) {\n    // your code here\n    return 0;\n}",
    "cpp": "int findCircleNum(vector<vector<int>>& isConnected) {\n    // your code here\n    return 0;\n}"
  },
  "testCases": [
    { "input": "[[1,1,0],[1,1,0],[0,0,1]]", "expectedOutputs": ["2"] },
    { "input": "[[1,0,0],[0,1,0],[0,0,1]]", "expectedOutputs": ["3"] },
    { "input": "[[1,1,1],[1,1,1],[1,1,1]]", "expectedOutputs": ["1"] },
    { "input": "[[1]]", "expectedOutputs": ["1"] },
    { "input": "[[1,0],[0,1]]", "expectedOutputs": ["2"] },
    { "input": "[[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]]", "expectedOutputs": ["1"] },
    { "input": "[[1,0,0,1],[0,1,1,0],[0,1,1,1],[1,0,1,1]]", "expectedOutputs": ["1"] },
    { "input": "[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]", "expectedOutputs": ["4"] },
    { "input": "[[1,1,0,0],[1,1,0,0],[0,0,1,1],[0,0,1,1]]", "expectedOutputs": ["2"] },
    { "input": "[[1,1],[1,1]]", "expectedOutputs": ["1"] }
  ]
},
{
  "id": 15,
  "title": "Longest Increasing Subsequence",
  "category": "arrays",
  "difficulty": "medium",
  "description": "Given an integer array nums, return the length of the longest strictly increasing subsequence.",
  "functionSignature": {
    "javascript": "function lengthOfLIS(nums) {\n  // your code here\n}",
    "python": "def length_of_lis(nums):\n    # your code here\n    pass",
    "java": "public int lengthOfLIS(int[] nums) {\n    // your code here\n    return 0;\n}",
    "cpp": "int lengthOfLIS(vector<int>& nums) {\n    // your code here\n    return 0;\n}"
  },
  "testCases": [
    { "input": "[10,9,2,5,3,7,101,18]", "expectedOutputs": ["4"] },
    { "input": "[0,1,0,3,2,3]", "expectedOutputs": ["4"] },
    { "input": "[7,7,7,7,7,7,7]", "expectedOutputs": ["1"] },
    { "input": "[4,10,4,3,8,9]", "expectedOutputs": ["3"] },
    { "input": "[1,3,6,7,9,4,10,5,6]", "expectedOutputs": ["6"] },
    { "input": "[1]", "expectedOutputs": ["1"] },
    { "input": "[1,2]", "expectedOutputs": ["2"] },
    { "input": "[2,2]", "expectedOutputs": ["1"] },
    { "input": "[3,1,2]", "expectedOutputs": ["2"] },
    { "input": "[0]", "expectedOutputs": ["1"] }
  ]
},
{
  "id": 16,
  "title": "Remove N-th Node From End of List",
  "category": "linked list",
  "difficulty": "medium",
  "description": "Given the head of a linked list, remove the n-th node from the end of the list and return its head.",
  "functionSignature": {
    "javascript": "function removeNthFromEnd(head, n) {\n  // your code here\n}",
    "python": "def remove_nth_from_end(head, n):\n    # your code here\n    pass",
    "java": "public ListNode removeNthFromEnd(ListNode head, int n) {\n    // your code here\n    return null;\n}",
    "cpp": "ListNode* removeNthFromEnd(ListNode* head, int n) {\n    // your code here\n    return nullptr;\n}"
  },
  "testCases": [
    { "input": "[1,2,3,4,5]\n2", "expectedOutputs": ["[1,2,3,5]"] },
    { "input": "[1]\n1", "expectedOutputs": ["[]"] },
    { "input": "[1,2]\n1", "expectedOutputs": ["[1]"] },
    { "input": "[1,2,3]\n3", "expectedOutputs": ["[2,3]"] },
    { "input": "[1,2,3]\n2", "expectedOutputs": ["[1,3]"] },
    { "input": "[1,2,3]\n1", "expectedOutputs": ["[1,2]"] },
    { "input": "[10,20,30,40]\n4", "expectedOutputs": ["[20,30,40]"] },
    { "input": "[1,2,3,4,5]\n5", "expectedOutputs": ["[2,3,4,5]"] },
    { "input": "[5,6,7,8,9]\n3", "expectedOutputs": ["[5,6,8,9]"] },
    { "input": "[2,4,6,8,10]\n2", "expectedOutputs": ["[2,4,6,10]"] }
  ]
},
{
  "id": 17,
  "title": "Maximum Depth of Binary Tree",
  "category": "binary tree",
  "difficulty": "easy",
  "description": "Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
  "functionSignature": {
    "javascript": "function maxDepth(root) {\n  // your code here\n}",
    "python": "def max_depth(root):\n    # your code here\n    pass",
    "java": "public int maxDepth(TreeNode root) {\n    // your code here\n    return 0;\n}",
    "cpp": "int maxDepth(TreeNode* root) {\n    // your code here\n    return 0;\n}"
  },
  "testCases": [
    { "input": "[3,9,20,null,null,15,7]", "expectedOutputs": ["3"] },
    { "input": "[1,null,2]", "expectedOutputs": ["2"] },
    { "input": "[]", "expectedOutputs": ["0"] },
    { "input": "[0]", "expectedOutputs": ["1"] },
    { "input": "[1,2,3,4,null,null,5]", "expectedOutputs": ["3"] },
    { "input": "[1,2,null,3,null,4,null]", "expectedOutputs": ["4"] },
    { "input": "[1,2,3,4,5]", "expectedOutputs": ["3"] },
    { "input": "[1,2,3,null,null,4,5]", "expectedOutputs": ["3"] },
    { "input": "[1,2,2,3,null,null,3]", "expectedOutputs": ["3"] },
    { "input": "[1,2,3,4,5,6,7]", "expectedOutputs": ["3"] }
  ]
},
{
  "id": 18,
  "title": "Course Schedule",
  "category": "graph",
  "difficulty": "medium",
  "description": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. Some courses may have prerequisites. Return true if it is possible to finish all courses.",
  "functionSignature": {
    "javascript": "function canFinish(numCourses, prerequisites) {\n  // your code here\n}",
    "python": "def can_finish(num_courses, prerequisites):\n    # your code here\n    pass",
    "java": "public boolean canFinish(int numCourses, int[][] prerequisites) {\n    // your code here\n    return false;\n}",
    "cpp": "bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n    // your code here\n    return false;\n}"
  },
  "testCases": [
    { "input": "2\n[[1,0]]", "expectedOutputs": ["true"] },
    { "input": "2\n[[1,0],[0,1]]", "expectedOutputs": ["false"] },
    { "input": "3\n[[0,1],[0,2],[1,2]]", "expectedOutputs": ["true"] },
    { "input": "3\n[[1,0],[2,1],[0,2]]", "expectedOutputs": ["false"] },
    { "input": "1\n[]", "expectedOutputs": ["true"] },
    { "input": "4\n[[1,0],[2,1],[3,2]]", "expectedOutputs": ["true"] },
    { "input": "3\n[[1,0],[2,1]]", "expectedOutputs": ["true"] },
    { "input": "3\n[[1,0],[0,2],[2,1]]", "expectedOutputs": ["false"] },
    { "input": "5\n[[1,4],[2,4],[3,1],[3,2]]", "expectedOutputs": ["true"] },
    { "input": "3\n[[1,0],[2,1],[1,2]]", "expectedOutputs": ["false"] }
  ]
},
{
  "id": 19,
  "title": "Product of Array Except Self",
  "category": "arrays",
  "difficulty": "medium",
  "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. Do not use division and solve it in O(n).",
  "functionSignature": {
    "javascript": "function productExceptSelf(nums) {\n  // your code here\n}",
    "python": "def product_except_self(nums):\n    # your code here\n    pass",
    "java": "public int[] productExceptSelf(int[] nums) {\n    // your code here\n    return new int[]{};\n}",
    "cpp": "vector<int> productExceptSelf(vector<int>& nums) {\n    // your code here\n    return {};\n}"
  },
  "testCases": [
    { "input": "[1,2,3,4]", "expectedOutputs": ["[24,12,8,6]"] },
    { "input": "[2,3,4,5]", "expectedOutputs": ["[60,40,30,24]"] },
    { "input": "[1,1,1,1]", "expectedOutputs": ["[1,1,1,1]"] },
    { "input": "[0,1,2,3]", "expectedOutputs": ["[6,0,0,0]"] },
    { "input": "[4,5,1,8]", "expectedOutputs": ["[40,32,160,20]"] },
    { "input": "[2,2,2,2]", "expectedOutputs": ["[8,8,8,8]"] },
    { "input": "[1,2]", "expectedOutputs": ["[2,1]"] },
    { "input": "[10,3,5]", "expectedOutputs": ["[15,50,30]"] },
    { "input": "[9,0,1]", "expectedOutputs": ["[0,9,0]"] },
    { "input": "[1,0]", "expectedOutputs": ["[0,1]"] }
  ]
},
{
  "id": 20,
  "title": "Palindrome Linked List",
  "category": "linked list",
  "difficulty": "easy",
  "description": "Given the head of a singly linked list, return true if it is a palindrome or false otherwise.",
  "functionSignature": {
    "javascript": "function isPalindrome(head) {\n  // your code here\n}",
    "python": "def is_palindrome(head):\n    # your code here\n    pass",
    "java": "public boolean isPalindrome(ListNode head) {\n    // your code here\n    return false;\n}",
    "cpp": "bool isPalindrome(ListNode* head) {\n    // your code here\n    return false;\n}"
  },
  "testCases": [
    { "input": "[1,2]", "expectedOutputs": ["false"] },
    { "input": "[1,2,2,1]", "expectedOutputs": ["true"] },
    { "input": "[1,2,3,2,1]", "expectedOutputs": ["true"] },
    { "input": "[1,2,3,4]", "expectedOutputs": ["false"] },
    { "input": "[1,2,1]", "expectedOutputs": ["true"] },
    { "input": "[1]", "expectedOutputs": ["true"] },
    { "input": "[1,1]", "expectedOutputs": ["true"] },
    { "input": "[1,0,1]", "expectedOutputs": ["true"] },
    { "input": "[1,2,3,3,2,1]", "expectedOutputs": ["true"] },
    { "input": "[1,2,3,4,5]", "expectedOutputs": ["false"] }
  ]
},
{
  "id": 21,
  "title": "Same Tree",
  "category": "binary tree",
  "difficulty": "easy",
  "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.",
  "functionSignature": {
    "javascript": "function isSameTree(p, q) {\n  // your code here\n}",
    "python": "def is_same_tree(p, q):\n    # your code here\n    pass",
    "java": "public boolean isSameTree(TreeNode p, TreeNode q) {\n    // your code here\n    return false;\n}",
    "cpp": "bool isSameTree(TreeNode* p, TreeNode* q) {\n    // your code here\n    return false;\n}"
  },
  "testCases": [
    { "input": "[1,2,3]\n[1,2,3]", "expectedOutputs": ["true"] },
    { "input": "[1,2]\n[1,null,2]", "expectedOutputs": ["false"] },
    { "input": "[1,2,1]\n[1,1,2]", "expectedOutputs": ["false"] },
    { "input": "[1]\n[1]", "expectedOutputs": ["true"] },
    { "input": "[1,null,2,3]\n[1,null,2,3]", "expectedOutputs": ["true"] },
    { "input": "[1,null,2]\n[1,2]", "expectedOutputs": ["false"] },
    { "input": "[1,2,3,4]\n[1,2,3]", "expectedOutputs": ["false"] },
    { "input": "[]\n[]", "expectedOutputs": ["true"] },
    { "input": "[5,6]\n[5,6]", "expectedOutputs": ["true"] },
    { "input": "[5,6]\n[6,5]", "expectedOutputs": ["false"] }
  ]
},
{
  "id": 22,
  "title": "Rotate Array",
  "category": "arrays",
  "difficulty": "easy",
  "description": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.",
  "functionSignature": {
    "javascript": "function rotate(nums, k) {\n  // your code here\n}",
    "python": "def rotate(nums, k):\n    # your code here\n    pass",
    "java": "public void rotate(int[] nums, int k) {\n    // your code here\n}",
    "cpp": "void rotate(vector<int>& nums, int k) {\n    // your code here\n}"
  },
  "testCases": [
    { "input": "[1,2,3,4,5,6,7]\n3", "expectedOutputs": ["[5,6,7,1,2,3,4]"] },
    { "input": "[-1,-100,3,99]\n2", "expectedOutputs": ["[3,99,-1,-100]"] },
    { "input": "[1,2]\n3", "expectedOutputs": ["[2,1]"] },
    { "input": "[1]\n0", "expectedOutputs": ["[1]"] },
    { "input": "[1,2,3]\n0", "expectedOutputs": ["[1,2,3]"] },
    { "input": "[1,2,3,4]\n4", "expectedOutputs": ["[1,2,3,4]"] },
    { "input": "[1,2,3,4,5]\n5", "expectedOutputs": ["[1,2,3,4,5]"] },
    { "input": "[1,2,3,4,5,6]\n2", "expectedOutputs": ["[5,6,1,2,3,4]"] },
    { "input": "[1,2,3,4,5]\n3", "expectedOutputs": ["[3,4,5,1,2]"] },
    { "input": "[1,2,3,4,5,6,7,8]\n4", "expectedOutputs": ["[5,6,7,8,1,2,3,4]"] }
  ]
},
{
  "id": 23,
  "title": "Merge k Sorted Lists",
  "category": "linked list",
  "difficulty": "hard",
  "description": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.",
  "functionSignature": {
    "javascript": "function mergeKLists(lists) {\n  // your code here\n}",
    "python": "def merge_k_lists(lists):\n    # your code here\n    pass",
    "java": "public ListNode mergeKLists(ListNode[] lists) {\n    // your code here\n    return null;\n}",
    "cpp": "ListNode* mergeKLists(vector<ListNode*>& lists) {\n    // your code here\n    return nullptr;\n}"
  },
  "testCases": [
    { "input": "[[1,4,5],[1,3,4],[2,6]]", "expectedOutputs": ["[1,1,2,3,4,4,5,6]"] },
    { "input": "[]", "expectedOutputs": ["[]"] },
    { "input": "[[]]", "expectedOutputs": ["[]"] },
    { "input": "[[2,3,5],[1,2,4]]", "expectedOutputs": ["[1,2,2,3,4,5]"] },
    { "input": "[[1],[0]]", "expectedOutputs": ["[0,1]"] },
    { "input": "[[1,2,3],[4,5],[6,7,8]]", "expectedOutputs": ["[1,2,3,4,5,6,7,8]"] },
    { "input": "[[3,5,7],[0,6],[2,4,8]]", "expectedOutputs": ["[0,2,3,4,5,6,7,8]"] },
    { "input": "[[],[1]]", "expectedOutputs": ["[1]"] },
    { "input": "[[1,3],[2,4]]", "expectedOutputs": ["[1,2,3,4]"] },
    { "input": "[[1,2,3],[],[4,5,6]]", "expectedOutputs": ["[1,2,3,4,5,6]"] }
  ]
},
{
  "id": 24,
  "title": "Lowest Common Ancestor of a Binary Tree",
  "category": "binary tree",
  "difficulty": "medium",
  "description": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.",
  "functionSignature": {
    "javascript": "function lowestCommonAncestor(root, p, q) {\n  // your code here\n}",
    "python": "def lowest_common_ancestor(root, p, q):\n    # your code here\n    pass",
    "java": "public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    // your code here\n    return null;\n}",
    "cpp": "TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n    // your code here\n    return nullptr;\n}"
  },
  "testCases": [
    { "input": "[3,5,1,6,2,0,8,null,null,7,4]\n5\n1", "expectedOutputs": ["3"] },
    { "input": "[3,5,1,6,2,0,8,null,null,7,4]\n5\n4", "expectedOutputs": ["5"] },
    { "input": "[1,2]\n1\n2", "expectedOutputs": ["1"] },
    { "input": "[1,2,3]\n2\n3", "expectedOutputs": ["1"] },
    { "input": "[2,1]\n2\n1", "expectedOutputs": ["2"] },
    { "input": "[6,2,8,0,4,7,9,null,null,3,5]\n2\n8", "expectedOutputs": ["6"] },
    { "input": "[6,2,8,0,4,7,9,null,null,3,5]\n0\n5", "expectedOutputs": ["2"] },
    { "input": "[3,1,4,null,2]\n2\n3", "expectedOutputs": ["3"] },
    { "input": "[3,5,1,6,2,0,8,null,null,7,4]\n6\n4", "expectedOutputs": ["5"] },
    { "input": "[3,5,1,6,2,0,8,null,null,7,4]\n7\n8", "expectedOutputs": ["3"] }
  ]
},
{
  "id": 25,
  "title": "Find the Town Judge",
  "category": "graph",
  "difficulty": "easy",
  "description": "In a town of n people labeled from 1 to n, there is a rumor that one of these people is the town judge. If the town judge exists, then: 1. The town judge trusts nobody. 2. Everybody (except for the town judge) trusts the town judge. Return the label of the town judge if the town judge exists and can be identified, or -1 otherwise.",
  "functionSignature": {
    "javascript": "function findJudge(n, trust) {\n  // your code here\n}",
    "python": "def find_judge(n, trust):\n    # your code here\n    pass",
    "java": "public int findJudge(int n, int[][] trust) {\n    // your code here\n    return -1;\n}",
    "cpp": "int findJudge(int n, vector<vector<int>>& trust) {\n    // your code here\n    return -1;\n}"
  },
  "testCases": [
    { "input": "2\n[[1,2]]", "expectedOutputs": ["2"] },
    { "input": "3\n[[1,3],[2,3]]", "expectedOutputs": ["3"] },
    { "input": "3\n[[1,3],[2,3],[3,1]]", "expectedOutputs": ["-1"] },
    { "input": "1\n[]", "expectedOutputs": ["1"] },
    { "input": "3\n[[1,2],[2,3]]", "expectedOutputs": ["-1"] },
    { "input": "4\n[[1,3],[1,4],[2,3],[2,4],[4,3]]", "expectedOutputs": ["3"] },
    { "input": "2\n[[1,2],[2,1]]", "expectedOutputs": ["-1"] },
    { "input": "3\n[[1,2],[2,3]]", "expectedOutputs": ["-1"] },
    { "input": "3\n[[1,2],[2,1],[3,1]]", "expectedOutputs": ["1"] },
    { "input": "3\n[]", "expectedOutputs": ["-1"] }
  ]
},
{
  "id": 26,
  "title": "Top K Frequent Elements",
  "category": "arrays",
  "difficulty": "medium",
  "description": "Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.",
  "functionSignature": {
    "javascript": "function topKFrequent(nums, k) {\n  // your code here\n}",
    "python": "def top_k_frequent(nums, k):\n    # your code here\n    pass",
    "java": "public int[] topKFrequent(int[] nums, int k) {\n    // your code here\n    return new int[]{};\n}",
    "cpp": "vector<int> topKFrequent(vector<int>& nums, int k) {\n    // your code here\n    return {};\n}"
  },
  "testCases": [
    { "input": "[1,1,1,2,2,3]\n2", "expectedOutputs": ["[1,2]", "[2,1]"] },
    { "input": "[1]\n1", "expectedOutputs": ["[1]"] },
    { "input": "[4,1,-1,2,-1,2,3]\n2", "expectedOutputs": ["[-1,2]", "[2,-1]"] },
    { "input": "[1,1,2,2,3,3,4,4]\n4", "expectedOutputs": ["[1,2,3,4]"] },
    { "input": "[5,5,5,5,6,6,7]\n2", "expectedOutputs": ["[5,6]", "[6,5]"] },
    { "input": "[1,2,3,4,5,6,7,8,9,10]\n1", "expectedOutputs": ["[1]", "[2]", "[3]", "[4]", "[5]", "[6]", "[7]", "[8]", "[9]", "[10]"] },
    { "input": "[1,1,1,2,2,3,3,3,4,4,4,4]\n1", "expectedOutputs": ["[4]"] },
    { "input": "[1,2,2,3,3,3,4,4,4,4]\n3", "expectedOutputs": ["[4,3,2]", "[4,2,3]", "[3,4,2]"] },
    { "input": "[5,5,4,4,4,6,6,6,6]\n2", "expectedOutputs": ["[6,4]", "[4,6]"] },
    { "input": "[1,1,1,1,2,3,4,5,6,7,8,9]\n1", "expectedOutputs": ["[1]"] }
  ]
},
{
  "id": 27,
  "title": "Search in Rotated Sorted Array",
  "category": "arrays",
  "difficulty": "medium",
  "description": "Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums. You must write an algorithm with O(log n) runtime complexity.",
  "functionSignature": {
    "javascript": "function search(nums, target) {\n  // your code here\n}",
    "python": "def search(nums, target):\n    # your code here\n    pass",
    "java": "public int search(int[] nums, int target) {\n    // your code here\n    return -1;\n}",
    "cpp": "int search(vector<int>& nums, int target) {\n    // your code here\n    return -1;\n}"
  },
  "testCases": [
    { "input": "[4,5,6,7,0,1,2]\n0", "expectedOutputs": ["4"] },
    { "input": "[4,5,6,7,0,1,2]\n3", "expectedOutputs": ["-1"] },
    { "input": "[1]\n0", "expectedOutputs": ["-1"] },
    { "input": "[1,3]\n3", "expectedOutputs": ["1"] },
    { "input": "[5,1,3]\n3", "expectedOutputs": ["2"] },
    { "input": "[6,7,1,2,3,4,5]\n6", "expectedOutputs": ["0"] },
    { "input": "[1,2,3,4,5,6,7]\n5", "expectedOutputs": ["4"] },
    { "input": "[1]\n1", "expectedOutputs": ["0"] },
    { "input": "[3,1]\n1", "expectedOutputs": ["1"] },
    { "input": "[2,3,4,5,6,7,8,9,1]\n9", "expectedOutputs": ["7"] }
  ]
},
{
  "id": 28,
  "title": "Pow(x, n)",
  "category": "arrays",
  "difficulty": "medium",
  "description": "Implement pow(x, n), which calculates x raised to the power n (i.e., x^n). You must not use built-in exponent functions.",
  "functionSignature": {
    "javascript": "function myPow(x, n) {\n  // your code here\n}",
    "python": "def my_pow(x, n):\n    # your code here\n    pass",
    "java": "public double myPow(double x, int n) {\n    // your code here\n    return 0.0;\n}",
    "cpp": "double myPow(double x, int n) {\n    // your code here\n    return 0.0;\n}"
  },
  "testCases": [
    { "input": "2.00000\n10", "expectedOutputs": ["1024.0"] },
    { "input": "2.10000\n3", "expectedOutputs": ["9.261"] },
    { "input": "2.00000\n-2", "expectedOutputs": ["0.25"] },
    { "input": "1.00000\n0", "expectedOutputs": ["1.0"] },
    { "input": "0.00001\n2147483647", "expectedOutputs": ["0.0"] },
    { "input": "2.00000\n0", "expectedOutputs": ["1.0"] },
    { "input": "34.00515\n-3", "expectedOutputs": ["3e-05"] },
    { "input": "0.00001\n-2147483648", "expectedOutputs": ["Infinity"] },
    { "input": "0\n0", "expectedOutputs": ["1.0"] },
    { "input": "0.5\n3", "expectedOutputs": ["0.125"] }
  ]
},
{
  "id": 29,
  "title": "Meeting Rooms II",
  "category": "arrays",
  "difficulty": "medium",
  "description": "Given an array of meeting time intervals where intervals[i] = [start_i, end_i], return the minimum number of conference rooms required.",
  "functionSignature": {
    "javascript": "function minMeetingRooms(intervals) {\n  // your code here\n}",
    "python": "def min_meeting_rooms(intervals):\n    # your code here\n    pass",
    "java": "public int minMeetingRooms(int[][] intervals) {\n    // your code here\n    return 0;\n}",
    "cpp": "int minMeetingRooms(vector<vector<int>>& intervals) {\n    // your code here\n    return 0;\n}"
  },
  "testCases": [
    { "input": "[[0,30],[5,10],[15,20]]", "expectedOutputs": ["2"] },
    { "input": "[[7,10],[2,4]]", "expectedOutputs": ["1"] },
    { "input": "[[0,5],[5,10]]", "expectedOutputs": ["1"] },
    { "input": "[[1,5],[2,6],[3,7]]", "expectedOutputs": ["3"] },
    { "input": "[[9,10],[4,9],[4,17]]", "expectedOutputs": ["2"] },
    { "input": "[[0,30],[35,40],[45,50]]", "expectedOutputs": ["1"] },
    { "input": "[[0,30],[10,15],[15,20]]", "expectedOutputs": ["2"] },
    { "input": "[[1,10],[2,3],[3,4],[4,5],[6,7],[7,8]]", "expectedOutputs": ["2"] },
    { "input": "[[13,15],[1,13]]", "expectedOutputs": ["1"] },
    { "input": "[[1,3],[2,4],[3,5],[4,6]]", "expectedOutputs": ["2"] }
  ]
},

{
  "id": 30,
  "title": "Subsets",
  "category": "arrays",
  "difficulty": "medium",
  "description": "Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets.",
  "functionSignature": {
    "javascript": "function subsets(nums) {\n  // your code here\n}",
    "python": "def subsets(nums):\n    # your code here\n    pass",
    "java": "public List<List<Integer>> subsets(int[] nums) {\n    // your code here\n    return new ArrayList<>();\n}",
    "cpp": "vector<vector<int>> subsets(vector<int>& nums) {\n    // your code here\n    return {};\n}"
  },
  "testCases": [
    { "input": "[1,2,3]", "expectedOutputs": ["[[],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]]"] },
    { "input": "[0]", "expectedOutputs": ["[[],[0]]"] },
    { "input": "[1,2]", "expectedOutputs": ["[[],[1],[2],[1,2]]"] },
    { "input": "[4,5,6]", "expectedOutputs": ["[[],[4],[5],[6],[4,5],[4,6],[5,6],[4,5,6]]"] },
    { "input": "[9]", "expectedOutputs": ["[[],[9]]"] },
    { "input": "[1,3]", "expectedOutputs": ["[[],[1],[3],[1,3]]"] },
    { "input": "[5,10]", "expectedOutputs": ["[[],[5],[10],[5,10]]"] },
    { "input": "[2,4,6]", "expectedOutputs": ["[[],[2],[4],[6],[2,4],[2,6],[4,6],[2,4,6]]"] },
    { "input": "[8,9]", "expectedOutputs": ["[[],[8],[9],[8,9]]"] },
    { "input": "[1,2,3,4]", "expectedOutputs": ["[[],[1],[2],[3],[4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4],[1,2,3],[1,2,4],[1,3,4],[2,3,4],[1,2,3,4]]"] }
  ]
},
{
  "id": 31,
  "title": "Reorder List",
  "category": "linked list",
  "difficulty": "medium",
  "description": "You are given the head of a singly linked list. Reorder the list so that the nodes are in the following order: first node, last node, second node, second last node, and so on.",
  "functionSignature": {
    "javascript": "function reorderList(head) {\n  // your code here\n}",
    "python": "def reorder_list(head):\n    # your code here\n    pass",
    "java": "public void reorderList(ListNode head) {\n    // your code here\n}",
    "cpp": "void reorderList(ListNode* head) {\n    // your code here\n}"
  },
  "testCases": [
    { "input": "[1,2,3,4]", "expectedOutputs": ["[1,4,2,3]"] },
    { "input": "[1,2,3,4,5]", "expectedOutputs": ["[1,5,2,4,3]"] },
    { "input": "[1,2]", "expectedOutputs": ["[1,2]"] },
    { "input": "[1]", "expectedOutputs": ["[1]"] },
    { "input": "[1,2,3]", "expectedOutputs": ["[1,3,2]"] },
    { "input": "[1,2,3,4,5,6]", "expectedOutputs": ["[1,6,2,5,3,4]"] },
    { "input": "[10,20]", "expectedOutputs": ["[10,20]"] },
    { "input": "[1,2,3,4,5,6,7]", "expectedOutputs": ["[1,7,2,6,3,5,4]"] },
    { "input": "[0,1,2,3]", "expectedOutputs": ["[0,3,1,2]"] },
    { "input": "[7]", "expectedOutputs": ["[7]"] }
  ]
},
{
  "id": 32,
  "title": "Invert Binary Tree",
  "category": "binary tree",
  "difficulty": "easy",
  "description": "Given the root of a binary tree, invert the tree, and return its root.",
  "functionSignature": {
    "javascript": "function invertTree(root) {\n  // your code here\n}",
    "python": "def invert_tree(root):\n    # your code here\n    pass",
    "java": "public TreeNode invertTree(TreeNode root) {\n    // your code here\n    return null;\n}",
    "cpp": "TreeNode* invertTree(TreeNode* root) {\n    // your code here\n    return nullptr;\n}"
  },
  "testCases": [
    { "input": "[4,2,7,1,3,6,9]", "expectedOutputs": ["[4,7,2,9,6,3,1]"] },
    { "input": "[2,1,3]", "expectedOutputs": ["[2,3,1]"] },
    { "input": "[]", "expectedOutputs": ["[]"] },
    { "input": "[1]", "expectedOutputs": ["[1]"] },
    { "input": "[1,2]", "expectedOutputs": ["[1,null,2]"] },
    { "input": "[1,null,2]", "expectedOutputs": ["[1,2]"] },
    { "input": "[3,5,1]", "expectedOutputs": ["[3,1,5]"] },
    { "input": "[4,2,null,1,3]", "expectedOutputs": ["[4,null,2,null,null,3,1]"] },
    { "input": "[1,2,3,4,null,null,5]", "expectedOutputs": ["[1,3,2,5,null,null,4]"] },
    { "input": "[7,6,9,2,null,8,10]", "expectedOutputs": ["[7,9,6,10,8,null,2]"] }
  ]
},
{
  "id": 33,
  "title": "Graph Valid Tree",
  "category": "graph",
  "difficulty": "medium",
  "description": "Given n nodes labeled from 0 to n - 1 and a list of edges, determine if the edges make up a valid tree.",
  "functionSignature": {
    "javascript": "function validTree(n, edges) {\n  // your code here\n}",
    "python": "def valid_tree(n, edges):\n    # your code here\n    pass",
    "java": "public boolean validTree(int n, int[][] edges) {\n    // your code here\n    return false;\n}",
    "cpp": "bool validTree(int n, vector<vector<int>>& edges) {\n    // your code here\n    return false;\n}"
  },
  "testCases": [
    { "input": "5\n[[0,1],[0,2],[0,3],[1,4]]", "expectedOutputs": ["true"] },
    { "input": "5\n[[0,1],[1,2],[2,3],[1,3],[1,4]]", "expectedOutputs": ["false"] },
    { "input": "1\n[]", "expectedOutputs": ["true"] },
    { "input": "2\n[[1,0]]", "expectedOutputs": ["true"] },
    { "input": "2\n[]", "expectedOutputs": ["false"] },
    { "input": "4\n[[0,1],[2,3]]", "expectedOutputs": ["false"] },
    { "input": "3\n[[0,1],[1,2]]", "expectedOutputs": ["true"] },
    { "input": "3\n[[0,1],[1,2],[2,0]]", "expectedOutputs": ["false"] },
    { "input": "4\n[[0,1],[1,2],[2,3]]", "expectedOutputs": ["true"] },
    { "input": "5\n[[0,1],[1,2],[2,3],[3,4],[4,0]]", "expectedOutputs": ["false"] }
  ]
},
{
  "id": 34,
  "title": "Merge Two Sorted Lists",
  "category": "linked list",
  "difficulty": "easy",
  "description": "Merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists.",
  "functionSignature": {
    "javascript": "function mergeTwoLists(l1, l2) {\n  // your code here\n}",
    "python": "def merge_two_lists(l1, l2):\n    # your code here\n    pass",
    "java": "public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n    // your code here\n    return null;\n}",
    "cpp": "ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n    // your code here\n    return nullptr;\n}"
  },
  "testCases": [
    { "input": "[1,2,4]\n[1,3,4]", "expectedOutputs": ["[1,1,2,3,4,4]"] },
    { "input": "[]\n[]", "expectedOutputs": ["[]"] },
    { "input": "[]\n[0]", "expectedOutputs": ["[0]"] },
    { "input": "[5]\n[1,2,3]", "expectedOutputs": ["[1,2,3,5]"] },
    { "input": "[1,3,5]\n[2,4,6]", "expectedOutputs": ["[1,2,3,4,5,6]"] },
    { "input": "[1]\n[1]", "expectedOutputs": ["[1,1]"] },
    { "input": "[1,2,3]\n[]", "expectedOutputs": ["[1,2,3]"] },
    { "input": "[1,3,5,7]\n[2,4]", "expectedOutputs": ["[1,2,3,4,5,7]"] },
    { "input": "[10,20]\n[5,30]", "expectedOutputs": ["[5,10,20,30]"] },
    { "input": "[0,1,2]\n[3,4,5]", "expectedOutputs": ["[0,1,2,3,4,5]"] }
  ]
},
{
  "id": 35,
  "title": "Find the Duplicate Number",
  "category": "arrays",
  "difficulty": "medium",
  "description": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive, return the duplicate number. There is only one repeated number.",
  "functionSignature": {
    "javascript": "function findDuplicate(nums) {\n  // your code here\n}",
    "python": "def find_duplicate(nums):\n    # your code here\n    pass",
    "java": "public int findDuplicate(int[] nums) {\n    // your code here\n    return -1;\n}",
    "cpp": "int findDuplicate(vector<int>& nums) {\n    // your code here\n    return -1;\n}"
  },
  "testCases": [
    { "input": "[1,3,4,2,2]", "expectedOutputs": ["2"] },
    { "input": "[3,1,3,4,2]", "expectedOutputs": ["3"] },
    { "input": "[1,1]", "expectedOutputs": ["1"] },
    { "input": "[1,1,2]", "expectedOutputs": ["1"] },
    { "input": "[2,2,2,2,2]", "expectedOutputs": ["2"] },
    { "input": "[4,3,1,4,2]", "expectedOutputs": ["4"] },
    { "input": "[5,2,5,1,3,4]", "expectedOutputs": ["5"] },
    { "input": "[6,4,3,2,1,6,5]", "expectedOutputs": ["6"] },
    { "input": "[9,7,8,9,6,4,3,2,1,5]", "expectedOutputs": ["9"] },
    { "input": "[10,9,8,7,6,5,4,3,2,1,10]", "expectedOutputs": ["10"] }
  ]
},
{
  "id": 36,
  "title": "Clone Graph",
  "category": "graph",
  "difficulty": "medium",
  "description": "Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node contains a val and a list of neighbors.",
  "functionSignature": {
    "javascript": "function cloneGraph(node) {\n  // your code here\n}",
    "python": "def clone_graph(node):\n    # your code here\n    pass",
    "java": "public Node cloneGraph(Node node) {\n    // your code here\n    return null;\n}",
    "cpp": "Node* cloneGraph(Node* node) {\n    // your code here\n    return nullptr;\n}"
  },
  "testCases": [
    { "input": "[]", "expectedOutputs": ["[]"] },
    { "input": "[[2,4],[1,3],[2,4],[1,3]]", "expectedOutputs": ["[[2,4],[1,3],[2,4],[1,3]]"] },
    { "input": "[[2],[1]]", "expectedOutputs": ["[[2],[1]]"] },
    { "input": "[[3],[3],[1,2]]", "expectedOutputs": ["[[3],[3],[1,2]]"] },
    { "input": "[[2,3],[1,3],[1,2]]", "expectedOutputs": ["[[2,3],[1,3],[1,2]]"] },
    { "input": "[[2,3,4],[1,3],[1,2,4],[1,3]]", "expectedOutputs": ["[[2,3,4],[1,3],[1,2,4],[1,3]]"] },
    { "input": "[[2,3],[1,4],[1,4],[2,3]]", "expectedOutputs": ["[[2,3],[1,4],[1,4],[2,3]]"] },
    { "input": "[[2],[1,3],[2]]", "expectedOutputs": ["[[2],[1,3],[2]]"] },
    { "input": "[[2,4],[1,3],[2,4],[1,3]]", "expectedOutputs": ["[[2,4],[1,3],[2,4],[1,3]]"] },
    { "input": "[[2,3],[1,3],[1,2]]", "expectedOutputs": ["[[2,3],[1,3],[1,2]]"] }
  ]
},
{
  "id": 37,
  "title": "Missing Number",
  "category": "arrays",
  "difficulty": "easy",
  "description": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.",
  "functionSignature": {
    "javascript": "function missingNumber(nums) {\n  // your code here\n}",
    "python": "def missing_number(nums):\n    # your code here\n    pass",
    "java": "public int missingNumber(int[] nums) {\n    // your code here\n    return -1;\n}",
    "cpp": "int missingNumber(vector<int>& nums) {\n    // your code here\n    return -1;\n}"
  },
  "testCases": [
    { "input": "[3,0,1]", "expectedOutputs": ["2"] },
    { "input": "[0,1]", "expectedOutputs": ["2"] },
    { "input": "[9,6,4,2,3,5,7,0,1]", "expectedOutputs": ["8"] },
    { "input": "[0]", "expectedOutputs": ["1"] },
    { "input": "[1]", "expectedOutputs": ["0"] },
    { "input": "[4,2,1,0]", "expectedOutputs": ["3"] },
    { "input": "[2,0]", "expectedOutputs": ["1"] },
    { "input": "[1,2]", "expectedOutputs": ["0"] },
    { "input": "[0,2]", "expectedOutputs": ["1"] },
    { "input": "[0,1,3,4]", "expectedOutputs": ["2"] }
  ]
},
{
  "id": 38,
  "title": "Intersection of Two Linked Lists",
  "category": "linked list",
  "difficulty": "easy",
  "description": "Given the heads of two singly linked lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection, return null.",
  "functionSignature": {
    "javascript": "function getIntersectionNode(headA, headB) {\n  // your code here\n}",
    "python": "def get_intersection_node(headA, headB):\n    # your code here\n    pass",
    "java": "public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n    // your code here\n    return null;\n}",
    "cpp": "ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {\n    // your code here\n    return nullptr;\n}"
  },
  "testCases": [
    { "input": "[4,1,8,4,5]\n[5,6,1,8,4,5]", "expectedOutputs": ["8"] },
    { "input": "[1,9,1,2,4]\n[3,2,4]", "expectedOutputs": ["2"] },
    { "input": "[2,6,4]\n[1,5]", "expectedOutputs": ["null"] },
    { "input": "[1]\n[1]", "expectedOutputs": ["1"] },
    { "input": "[3,7,8,10]\n[99,1,8,10]", "expectedOutputs": ["8"] },
    { "input": "[1,2,3]\n[4,5,6]", "expectedOutputs": ["null"] },
    { "input": "[5,6,7,8,9]\n[0,1,2,3,4,8,9]", "expectedOutputs": ["8"] },
    { "input": "[1,2,3,4]\n[6,7,4]", "expectedOutputs": ["4"] },
    { "input": "[2]\n[3]", "expectedOutputs": ["null"] },
    { "input": "[1,2,3]\n[1,2,3]", "expectedOutputs": ["1"] }
  ]
},
{
  "id": 39,
  "title": "Lowest Common Ancestor of a Binary Tree",
  "category": "binary tree",
  "difficulty": "medium",
  "description": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.",
  "functionSignature": {
    "javascript": "function lowestCommonAncestor(root, p, q) {\n  // your code here\n}",
    "python": "def lowest_common_ancestor(root, p, q):\n    # your code here\n    pass",
    "java": "public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    // your code here\n    return null;\n}",
    "cpp": "TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n    // your code here\n    return nullptr;\n}"
  },
  "testCases": [
    { "input": "[3,5,1,6,2,0,8,null,null,7,4]\n5\n1", "expectedOutputs": ["3"] },
    { "input": "[3,5,1,6,2,0,8,null,null,7,4]\n5\n4", "expectedOutputs": ["5"] },
    { "input": "[1,2]\n1\n2", "expectedOutputs": ["1"] },
    { "input": "[6,2,8,0,4,7,9,null,null,3,5]\n2\n8", "expectedOutputs": ["6"] },
    { "input": "[6,2,8,0,4,7,9,null,null,3,5]\n2\n4", "expectedOutputs": ["2"] },
    { "input": "[2,1]\n2\n1", "expectedOutputs": ["2"] },
    { "input": "[1]\n1\n1", "expectedOutputs": ["1"] },
    { "input": "[3,5,1,6,2,0,8,null,null,7,4]\n7\n4", "expectedOutputs": ["2"] },
    { "input": "[3,5,1,6,2,0,8,null,null,7,4]\n6\n4", "expectedOutputs": ["5"] },
    { "input": "[3,5,1,6,2,0,8,null,null,7,4]\n0\n8", "expectedOutputs": ["1"] }
  ]
},
{
  "id": 40,
  "title": "Course Schedule",
  "category": "graph",
  "difficulty": "medium",
  "description": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. Some courses may have prerequisites. Return true if it is possible to finish all courses.",
  "functionSignature": {
    "javascript": "function canFinish(numCourses, prerequisites) {\n  // your code here\n}",
    "python": "def can_finish(num_courses, prerequisites):\n    # your code here\n    pass",
    "java": "public boolean canFinish(int numCourses, int[][] prerequisites) {\n    // your code here\n    return false;\n}",
    "cpp": "bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n    // your code here\n    return false;\n}"
  },
  "testCases": [
    { "input": "2\n[[1,0]]", "expectedOutputs": ["true"] },
    { "input": "2\n[[1,0],[0,1]]", "expectedOutputs": ["false"] },
    { "input": "4\n[[1,0],[2,1],[3,2]]", "expectedOutputs": ["true"] },
    { "input": "3\n[[0,1],[1,2],[2,0]]", "expectedOutputs": ["false"] },
    { "input": "5\n[]", "expectedOutputs": ["true"] },
    { "input": "1\n[]", "expectedOutputs": ["true"] },
    { "input": "3\n[[1,0],[2,1]]", "expectedOutputs": ["true"] },
    { "input": "3\n[[0,1],[1,2],[2,1]]", "expectedOutputs": ["false"] },
    { "input": "6\n[[1,0],[2,1],[3,2],[1,3]]", "expectedOutputs": ["false"] },
    { "input": "3\n[[0,2],[1,2]]", "expectedOutputs": ["true"] }
  ]
},
{
  "id": 41,
  "title": "Majority Element",
  "category": "arrays",
  "difficulty": "easy",
  "description": "Given an array nums of size n, return the majority element. The majority element is the element that appears more than n / 2 times. You may assume that the majority element always exists in the array.",
  "functionSignature": {
    "javascript": "function majorityElement(nums) {\n  // your code here\n}",
    "python": "def majority_element(nums):\n    # your code here\n    pass",
    "java": "public int majorityElement(int[] nums) {\n    // your code here\n    return -1;\n}",
    "cpp": "int majorityElement(vector<int>& nums) {\n    // your code here\n    return -1;\n}"
  },
  "testCases": [
    { "input": "[3,2,3]", "expectedOutputs": ["3"] },
    { "input": "[2,2,1,1,1,2,2]", "expectedOutputs": ["2"] },
    { "input": "[1]", "expectedOutputs": ["1"] },
    { "input": "[1,1,1,2,3]", "expectedOutputs": ["1"] },
    { "input": "[4,4,5,4,6,4,4]", "expectedOutputs": ["4"] },
    { "input": "[9,9,9,1,2,3,9]", "expectedOutputs": ["9"] },
    { "input": "[2,2,2,2,2,2,2]", "expectedOutputs": ["2"] },
    { "input": "[7,7,5,7,5,5,7]", "expectedOutputs": ["7"] },
    { "input": "[0,0,0,1,1]", "expectedOutputs": ["0"] },
    { "input": "[10,10,10,20,30]", "expectedOutputs": ["10"] }
  ]
},
{
  "id": 42,
  "title": "Linked List Cycle",
  "category": "linked list",
  "difficulty": "easy",
  "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it. Return true if there is a cycle, otherwise return false.",
  "functionSignature": {
    "javascript": "function hasCycle(head) {\n  // your code here\n}",
    "python": "def has_cycle(head):\n    # your code here\n    pass",
    "java": "public boolean hasCycle(ListNode head) {\n    // your code here\n    return false;\n}",
    "cpp": "bool hasCycle(ListNode *head) {\n    // your code here\n    return false;\n}"
  },
  "testCases": [
    { "input": "[3,2,0,-4] (pos = 1)", "expectedOutputs": ["true"] },
    { "input": "[1,2] (pos = 0)", "expectedOutputs": ["true"] },
    { "input": "[1] (pos = -1)", "expectedOutputs": ["false"] },
    { "input": "[]", "expectedOutputs": ["false"] },
    { "input": "[1,2,3,4] (pos = 2)", "expectedOutputs": ["true"] },
    { "input": "[1,2,3,4] (pos = -1)", "expectedOutputs": ["false"] },
    { "input": "[1,1] (pos = 1)", "expectedOutputs": ["true"] },
    { "input": "[0] (pos = 0)", "expectedOutputs": ["true"] },
    { "input": "[0] (pos = -1)", "expectedOutputs": ["false"] },
    { "input": "[1,2,3] (pos = 0)", "expectedOutputs": ["true"] }
  ]
},
{
  "id": 43,
  "title": "Maximum Depth of Binary Tree",
  "category": "binary tree",
  "difficulty": "easy",
  "description": "Given the root of a binary tree, return its maximum depth. A binary tree's depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
  "functionSignature": {
    "javascript": "function maxDepth(root) {\n  // your code here\n}",
    "python": "def max_depth(root):\n    # your code here\n    pass",
    "java": "public int maxDepth(TreeNode root) {\n    // your code here\n    return 0;\n}",
    "cpp": "int maxDepth(TreeNode* root) {\n    // your code here\n    return 0;\n}"
  },
  "testCases": [
    { "input": "[3,9,20,null,null,15,7]", "expectedOutputs": ["3"] },
    { "input": "[1,null,2]", "expectedOutputs": ["2"] },
    { "input": "[]", "expectedOutputs": ["0"] },
    { "input": "[0]", "expectedOutputs": ["1"] },
    { "input": "[1,2,3,4,null,null,5]", "expectedOutputs": ["3"] },
    { "input": "[1,2,2,3,3,null,null,4,4]", "expectedOutputs": ["4"] },
    { "input": "[1,2]", "expectedOutputs": ["2"] },
    { "input": "[1,2,3,4,5,6,7]", "expectedOutputs": ["3"] },
    { "input": "[1,null,2,null,3,null,4]", "expectedOutputs": ["4"] },
    { "input": "[1,2,3,null,null,4,5]", "expectedOutputs": ["3"] }
  ]
},
{
  "id": 44,
  "title": "Redundant Connection",
  "category": "graph",
  "difficulty": "medium",
  "description": "In this problem, a tree is a connected graph with no cycles. You are given a graph that started as a tree with n nodes. An extra edge was added. Return the edge that can be removed to restore the tree property.",
  "functionSignature": {
    "javascript": "function findRedundantConnection(edges) {\n  // your code here\n}",
    "python": "def find_redundant_connection(edges):\n    # your code here\n    pass",
    "java": "public int[] findRedundantConnection(int[][] edges) {\n    // your code here\n    return new int[2];\n}",
    "cpp": "vector<int> findRedundantConnection(vector<vector<int>>& edges) {\n    // your code here\n    return {};\n}"
  },
  "testCases": [
    { "input": "[[1,2],[1,3],[2,3]]", "expectedOutputs": ["[2,3]"] },
    { "input": "[[1,2],[2,3],[3,4],[1,4],[1,5]]", "expectedOutputs": ["[1,4]"] },
    { "input": "[[1,2],[2,3],[3,1]]", "expectedOutputs": ["[3,1]"] },
    { "input": "[[1,2],[1,3],[2,4],[1,4]]", "expectedOutputs": ["[1,4]"] },
    { "input": "[[1,5],[3,4],[3,5],[4,5],[2,4]]", "expectedOutputs": ["[4,5]"] },
    { "input": "[[1,2],[2,3],[3,4],[4,1],[1,5]]", "expectedOutputs": ["[4,1]"] },
    { "input": "[[1,2],[2,3],[3,4],[4,5],[1,5]]", "expectedOutputs": ["[1,5]"] },
    { "input": "[[1,2],[2,3],[3,4],[1,4]]", "expectedOutputs": ["[1,4]"] },
    { "input": "[[1,2],[2,3],[1,3]]", "expectedOutputs": ["[1,3]"] },
    { "input": "[[1,2],[1,3],[2,3],[3,4],[4,5]]", "expectedOutputs": ["[2,3]"] }
  ]
},
{
  "id": 45,
  "title": "Rotate Array",
  "category": "arrays",
  "difficulty": "medium",
  "description": "Given an array, rotate the array to the right by k steps, where k is non-negative.",
  "functionSignature": {
    "javascript": "function rotate(nums, k) {\n  // your code here\n}",
    "python": "def rotate(nums, k):\n    # your code here\n    pass",
    "java": "public void rotate(int[] nums, int k) {\n    // your code here\n}",
    "cpp": "void rotate(vector<int>& nums, int k) {\n    // your code here\n}"
  },
  "testCases": [
    { "input": "[1,2,3,4,5,6,7]\n3", "expectedOutputs": ["[5,6,7,1,2,3,4]"] },
    { "input": "[-1,-100,3,99]\n2", "expectedOutputs": ["[3,99,-1,-100]"] },
    { "input": "[1,2]\n3", "expectedOutputs": ["[2,1]"] },
    { "input": "[1]\n0", "expectedOutputs": ["[1]"] },
    { "input": "[1,2,3]\n3", "expectedOutputs": ["[1,2,3]"] },
    { "input": "[1,2,3,4,5]\n1", "expectedOutputs": ["[5,1,2,3,4]"] },
    { "input": "[1,2,3,4,5,6]\n2", "expectedOutputs": ["[5,6,1,2,3,4]"] },
    { "input": "[1,2,3,4]\n5", "expectedOutputs": ["[4,1,2,3]"] },
    { "input": "[0,0,0,0]\n1", "expectedOutputs": ["[0,0,0,0]"] },
    { "input": "[1,2,3,4,5]\n0", "expectedOutputs": ["[1,2,3,4,5]"] }
  ]
}

]
