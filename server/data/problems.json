[
  {
    "id": 2,
    "title": "Two Sum",
    "category": "arrays",
    "difficulty": "easy",
    "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Return the answer in any order.",
    "functionSignature": {
      "javascript": "function twoSum(nums, target) {\n  // your code here\n}",
      "python": "def two_sum(nums, target):\n    # your code here\n    pass",
      "java": "public int[] twoSum(int[] nums, int target) {\n    // your code here\n    return new int[2];\n}",
      "cpp": "vector<int> twoSum(vector<int>& nums, int target) {\n    // your code here\n    return {};\n}"
    },
       "examples": [
      {
        "input": "[2,7,11,15], 9",
        "output": "[0,1]",
        "explanation": "The numbers at indices 0 and 1 add up to 9."
      },
      {
        "input": "[3,2,4], 6",
        "output": "[1,2]",
        "explanation": "Elements at index 1 and 2 sum to 6."
      }
    ],
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "Exactly one valid answer exists"
    ],
    "testCases": [
      { "input": "[2,7,11,15]\n9", "expectedOutputs": ["[0,1]"] },
      { "input": "[3,2,4]\n6", "expectedOutputs": ["[1,2]"] },
      { "input": "[3,3]\n6", "expectedOutputs": ["[0,1]"] },
      { "input": "[1,2,3,4]\n5", "expectedOutputs": ["[0,3]", "[1,2]"] },
      { "input": "[0,4,3,0]\n0", "expectedOutputs": ["[0,3]", "[3,0]"] },
      { "input": "[1,1,1,1,2]\n3", "expectedOutputs": ["[3,4]", "[2,4]", "[1,4]", "[0,4]"] },
      { "input": "[0,0,0,1,5]\n6", "expectedOutputs": ["[3,4]"] },
      { "input": "[1,2,5,6,10]\n15", "expectedOutputs": ["[3,4]", "[2,4]"] },
      { "input": "[2,5,5,11]\n10", "expectedOutputs": ["[1,2]"] },
      { "input": "[1,2]\n3", "expectedOutputs": ["[0,1]"] }
    ]
  },
  {
    "id": 3,
    "title": "Add Two Numbers",
    "category": "linked list",
    "difficulty": "medium",
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.",
    "functionSignature": {
        "javascript": "function addTwoNumbers(l1, l2) {\n  // your code here\n}",
        "python": "def add_two_numbers(l1, l2):\n    # your code here\n    pass",
        "java": "public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    // your code here\n    return null;\n}",
        "cpp": "ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n    // your code here\n    return nullptr;\n}"
    },
      "examples": [
      {
        "input": "[2,4,3], [5,6,4]",
        "output": "[7,0,8]",
        "explanation": "342 + 465 = 807, stored in reverse."
      },
      {
        "input": "[0], [0]",
        "output": "[0]",
        "explanation": "0 + 0 = 0."
      }
    ],
    "constraints": [
      "Each list is non-empty",
      "0 <= Node.val <= 9",
      "Digits stored in reverse order"
    ],
    "testCases": [
        { "input": "[2,4,3]\n[5,6,4]", "expectedOutputs": ["[7,0,8]"] },
        { "input": "[0]\n[0]", "expectedOutputs": ["[0]"] },
        { "input": "[9,9,9,9,9,9,9]\n[9,9,9,9]", "expectedOutputs": ["[8,9,9,9,0,0,0,1]"] },
        { "input": "[1]\n[9,9,9]", "expectedOutputs": ["[0,0,0,1]"] },
        { "input": "[9]\n[1]", "expectedOutputs": ["[0,1]"] },
        { "input": "[1,8]\n[0]", "expectedOutputs": ["[1,8]"] },
        { "input": "[5]\n[5]", "expectedOutputs": ["[0,1]"] },
        { "input": "[2,4]\n[5,6,4]", "expectedOutputs": ["[7,0,5]"] },
        { "input": "[0,1]\n[0,1,2]", "expectedOutputs": ["[0,2,2]"] },
        { "input": "[1,2,3]\n[0,0,0]", "expectedOutputs": ["[1,2,3]"] }
    ]
    },
    {
  "id": 4,
  "title": "Binary Tree Inorder Traversal",
  "category": "binary tree",
  "difficulty": "medium",
  "description": "Given the root of a binary tree, return the inorder traversal of its nodes' values.",
  "functionSignature": {
    "javascript": "function inorderTraversal(root) {\n  // your code here\n}",
    "python": "def inorder_traversal(root):\n    # your code here\n    pass",
    "java": "public List<Integer> inorderTraversal(TreeNode root) {\n    // your code here\n    return new ArrayList<>();\n}",
    "cpp": "vector<int> inorderTraversal(TreeNode* root) {\n    // your code here\n    return {};\n}"
  },
  "examples": [
      {
        "input": "[1,null,2,3]",
        "output": "[1,3,2]",
        "explanation": "Inorder of [1,null,2,3] is [1,3,2]."
      },
      {
        "input": "[]",
        "output": "[]",
        "explanation": "Empty tree returns empty traversal."
      }
    ],
    "constraints": [
      "Number of nodes ≤ 100",
      "-100 <= Node.val <= 100"
    ],
  "testCases": [
    { "input": "[1,null,2,3]", "expectedOutputs": ["[1,3,2]"] },
    { "input": "[]", "expectedOutputs": ["[]"] },
    { "input": "[1]", "expectedOutputs": ["[1]"] },
    { "input": "[1,2]", "expectedOutputs": ["[2,1]"] },
    { "input": "[1,null,2]", "expectedOutputs": ["[1,2]"] },
    { "input": "[3,1,4,null,2]", "expectedOutputs": ["[1,2,3,4]"] },
    { "input": "[5,3,6,2,4]", "expectedOutputs": ["[2,3,4,5,6]"] },
    { "input": "[2,null,3,null,4,null,5]", "expectedOutputs": ["[2,3,4,5]"] },
    { "input": "[5,1,6,null,null,null,8]", "expectedOutputs": ["[1,5,6,8]"] },
    { "input": "[1,2,3,4,5]", "expectedOutputs": ["[4,2,5,1,3]"] }
  ]
},
{
  "id": 5,
  "title": "Number of Connected Components in an Undirected Graph",
  "category": "graph",
  "difficulty": "medium",
  "description": "You have a graph of `n` nodes. You are given an integer `n` and an array `edges` where `edges[i] = [a_i, b_i]` indicates that there is an edge between a_i and b_i. Return the number of connected components in the graph.",
  "functionSignature": {
    "javascript": "function countComponents(n, edges) {\n  // your code here\n}",
    "python": "def count_components(n, edges):\n    # your code here\n    pass",
    "java": "public int countComponents(int n, int[][] edges) {\n    // your code here\n    return 0;\n}",
    "cpp": "int countComponents(int n, vector<vector<int>>& edges) {\n    // your code here\n    return 0;\n}"
  },
   "examples": [
      {
        "input": "n = 5, edges = [[0,1],[1,2],[3,4]]",
        "output": "2",
        "explanation": "There are 2 disconnected components."
      },
      {
        "input": "n = 5, edges = [[0,1],[1,2],[2,3],[3,4]]",
        "output": "1",
        "explanation": "All nodes are connected."
      }
    ],
    "constraints": [
      "1 <= n <= 2000",
      "1 <= edges.length <= 5000",
      "0 <= edges[i][0], edges[i][1] < n",
      "No duplicate edges"
    ],
  "testCases": [
    { "input": "5\n[[0,1],[1,2],[3,4]]", "expectedOutputs": ["2"] },
    { "input": "5\n[[0,1],[1,2],[2,3],[3,4]]", "expectedOutputs": ["1"] },
    { "input": "4\n[[2,3],[1,2],[1,3]]", "expectedOutputs": ["2"] },
    { "input": "2\n[]", "expectedOutputs": ["2"] },
    { "input": "3\n[[0,1],[1,2]]", "expectedOutputs": ["1"] },
    { "input": "4\n[[0,1],[2,3]]", "expectedOutputs": ["2"] },
    { "input": "6\n[[0,1],[2,3],[4,5]]", "expectedOutputs": ["3"] },
    { "input": "1\n[]", "expectedOutputs": ["1"] },
    { "input": "3\n[[0,1],[0,2]]", "expectedOutputs": ["1"] },
    { "input": "4\n[[0,1]]", "expectedOutputs": ["3"] }
  ]
},
  {
    "id": 7,
    "title": "Reverse Linked List",
    "category": "linked list",
    "difficulty": "easy",
    "description": "Given the head of a singly linked list, reverse the list, and return the reversed list.",
    "functionSignature": {
      "javascript": "function reverseList(head) {\n  // your code here\n}",
      "python": "def reverse_list(head):\n    # your code here\n    pass",
      "java": "public ListNode reverseList(ListNode head) {\n    // your code here\n    return null;\n}",
      "cpp": "ListNode* reverseList(ListNode* head) {\n    // your code here\n    return nullptr;\n}"
    },
     "examples": [
      {
        "input": "[1,2,3,4,5]",
        "output": "[5,4,3,2,1]",
        "explanation": "The list is reversed."
      },
      {
        "input": "[1,2]",
        "output": "[2,1]",
        "explanation": "Only two elements; order is flipped."
      }
    ],
    "constraints": [
      "The number of nodes in the list is in the range [0, 5000]",
      "-5000 <= Node.val <= 5000"
    ],
    "testCases": [
      { "input": "[1,2,3,4,5]", "expectedOutputs": ["[5,4,3,2,1]"] },
      { "input": "[1,2]", "expectedOutputs": ["[2,1]"] },
      { "input": "[]", "expectedOutputs": ["[]"] },
      { "input": "[1]", "expectedOutputs": ["[1]"] },
      { "input": "[1,2,3]", "expectedOutputs": ["[3,2,1]"] },
      { "input": "[1,1,2]", "expectedOutputs": ["[2,1,1]"] },
      { "input": "[2,3,4,5]", "expectedOutputs": ["[5,4,3,2]"] },
      { "input": "[10,20]", "expectedOutputs": ["[20,10]"] },
      { "input": "[7]", "expectedOutputs": ["[7]"] },
      { "input": "[5,4,3,2,1]", "expectedOutputs": ["[1,2,3,4,5]"] }
    ]
  },
  {
    "id": 8,
    "title": "Symmetric Tree",
    "category": "binary tree",
    "difficulty": "easy",
    "description": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).",
    "functionSignature": {
      "javascript": "function isSymmetric(root) {\n  // your code here\n}",
      "python": "def is_symmetric(root):\n    # your code here\n    pass",
      "java": "public boolean isSymmetric(TreeNode root) {\n    // your code here\n    return false;\n}",
      "cpp": "bool isSymmetric(TreeNode* root) {\n    // your code here\n    return false;\n}"
    },
       "examples": [
      {
        "input": "[1,2,2,3,4,4,3]",
        "output": "true",
        "explanation": "Mirror image on both sides."
      },
      {
        "input": "[1,2,2,null,3,null,3]",
        "output": "false",
        "explanation": "Not symmetric."
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range [1, 1000]",
      "-100 <= Node.val <= 100"
    ],
    "testCases": [
      { "input": "[1,2,2,3,4,4,3]", "expectedOutputs": ["true"] },
      { "input": "[1,2,2,null,3,null,3]", "expectedOutputs": ["false"] },
      { "input": "[]", "expectedOutputs": ["true"] },
      { "input": "[1]", "expectedOutputs": ["true"] },
      { "input": "[1,2,2,null,3,3]", "expectedOutputs": ["false"] },
      { "input": "[1,2,2,2,null,2]", "expectedOutputs": ["false"] },
      { "input": "[1,2,2,3,null,null,3]", "expectedOutputs": ["true"] },
      { "input": "[1,null,2]", "expectedOutputs": ["false"] },
      { "input": "[1,2,2,3,4,4,3,5]", "expectedOutputs": ["false"] },
      { "input": "[1,2,2,null,3,3,null]", "expectedOutputs": ["true"] }
    ]
  },

{
  "id": 10,
  "title": "Merge Two Sorted Lists",
  "category": "linked list",
  "difficulty": "easy",
  "description": "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.",
  "functionSignature": {
    "javascript": "function mergeTwoLists(list1, list2) {\n  // your code here\n}",
    "python": "def merge_two_lists(list1, list2):\n    # your code here\n    pass",
    "java": "public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n    // your code here\n    return null;\n}",
    "cpp": "ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n    // your code here\n    return nullptr;\n}"
  },
      "examples": [
      {
        "input": "[1,2,4], [1,3,4]",
        "output": "[1,1,2,3,4,4]",
        "explanation": "Merging two sorted linked lists."
      },
      {
        "input": "[], [0]",
        "output": "[0]",
        "explanation": "One list is empty."
      }
    ],
    "constraints": [
      "The number of nodes in both lists is in the range [0, 50]",
      "-100 <= Node.val <= 100",
      "Both lists are sorted"
    ],
  "testCases": [
    { "input": "[1,2,4]\n[1,3,4]", "expectedOutputs": ["[1,1,2,3,4,4]"] },
    { "input": "[]\n[]", "expectedOutputs": ["[]"] },
    { "input": "[]\n[0]", "expectedOutputs": ["[0]"] },
    { "input": "[5]\n[1,2,3]", "expectedOutputs": ["[1,2,3,5]"] },
    { "input": "[2,6,7]\n[1,3,5]", "expectedOutputs": ["[1,2,3,5,6,7]"] },
    { "input": "[1]\n[1]", "expectedOutputs": ["[1,1]"] },
    { "input": "[1,2,4]\n[]", "expectedOutputs": ["[1,2,4]"] },
    { "input": "[1,3,5,7]\n[2,4,6,8]", "expectedOutputs": ["[1,2,3,4,5,6,7,8]"] },
    { "input": "[0,2,4]\n[1,3,5]", "expectedOutputs": ["[0,1,2,3,4,5]"] },
    { "input": "[5,10]\n[2,4,6]", "expectedOutputs": ["[2,4,5,6,10]"] }
  ]
},
{
  "id": 11,
  "title": "Validate Binary Search Tree",
  "category": "binary tree",
  "difficulty": "medium",
  "description": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).",
  "functionSignature": {
    "javascript": "function isValidBST(root) {\n  // your code here\n}",
    "python": "def is_valid_bst(root):\n    # your code here\n    pass",
    "java": "public boolean isValidBST(TreeNode root) {\n    // your code here\n    return false;\n}",
    "cpp": "bool isValidBST(TreeNode* root) {\n    // your code here\n    return false;\n}"
  },
     "examples": [
      {
        "input": "[2,1,3]",
        "output": "true",
        "explanation": "Valid in-order sequence."
      },
      {
        "input": "[5,1,4,null,null,3,6]",
        "output": "false",
        "explanation": "Node 3 is in wrong position."
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^4]",
      "-2^31 <= Node.val <= 2^31 - 1"
    ],
  "testCases": [
    { "input": "[2,1,3]", "expectedOutputs": ["true"] },
    { "input": "[5,1,4,null,null,3,6]", "expectedOutputs": ["false"] },
    { "input": "[1,1]", "expectedOutputs": ["false"] },
    { "input": "[]", "expectedOutputs": ["true"] },
    { "input": "[10,5,15,null,null,6,20]", "expectedOutputs": ["false"] },
    { "input": "[2,1,4,null,null,3,5]", "expectedOutputs": ["true"] },
    { "input": "[3,1,5,null,2]", "expectedOutputs": ["true"] },
    { "input": "[3,1,5,0,2,4,6]", "expectedOutputs": ["true"] },
    { "input": "[2,null,1]", "expectedOutputs": ["false"] },
    { "input": "[1,null,2,null,3]", "expectedOutputs": ["true"] }
  ]
},
{
  "id": 12,
  "title": "Clone Graph",
  "category": "graph",
  "difficulty": "medium",
  "description": "Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node contains a value and a list of its neighbors.",
  "functionSignature": {
    "javascript": "function cloneGraph(node) {\n  // your code here\n}",
    "python": "def clone_graph(node):\n    # your code here\n    pass",
    "java": "public Node cloneGraph(Node node) {\n    // your code here\n    return null;\n}",
    "cpp": "Node* cloneGraph(Node* node) {\n    // your code here\n    return nullptr;\n}"
  },
     "examples": [
      {
        "input": "[[2,4],[1,3],[2,4],[1,3]]",
        "output": "[[2,4],[1,3],[2,4],[1,3]]",
        "explanation": "The cloned graph structure matches the original."
      },
      {
        "input": "[]",
        "output": "[]",
        "explanation": "Empty graph returns empty."
      }
    ],
    "constraints": [
      "The number of nodes in the graph is in the range [0, 100]",
      "1 <= Node.val <= 100",
      "Node.val is unique",
      "There are no repeated edges and no self-loops"
    ],
  "testCases": [
    { "input": "[[2,4],[1,3],[2,4],[1,3]]", "expectedOutputs": ["[[2,4],[1,3],[2,4],[1,3]]"] },
    { "input": "[]", "expectedOutputs": ["[]"] },
    { "input": "[[2],[1]]", "expectedOutputs": ["[[2],[1]]"] },
    { "input": "[[2,3,4],[1,3,4],[1,2,4],[1,2,3]]", "expectedOutputs": ["[[2,3,4],[1,3,4],[1,2,4],[1,2,3]]"] },
    { "input": "[[2,3],[1,3],[1,2]]", "expectedOutputs": ["[[2,3],[1,3],[1,2]]"] },
    { "input": "[[2,3],[1],[1]]", "expectedOutputs": ["[[2,3],[1],[1]]"] },
    { "input": "[[2],[1]]", "expectedOutputs": ["[[2],[1]]"] },
    { "input": "[[2],[1,3],[2]]", "expectedOutputs": ["[[2],[1,3],[2]]"] },
    { "input": "[[2,4],[1,3],[2,4],[1,3]]", "expectedOutputs": ["[[2,4],[1,3],[2,4],[1,3]]"] },
    { "input": "[[2],[1]]", "expectedOutputs": ["[[2],[1]]"] }
  ]
},
{
  "id": 13,
  "title": "Detect Cycle in Linked List",
  "category": "linked list",
  "difficulty": "medium",
  "description": "Given the head of a linked list, determine if the linked list has a cycle in it. Return true if there is a cycle, otherwise false.",
  "functionSignature": {
    "javascript": "function hasCycle(head) {\n  // your code here\n}",
    "python": "def has_cycle(head):\n    # your code here\n    pass",
    "java": "public boolean hasCycle(ListNode head) {\n    // your code here\n    return false;\n}",
    "cpp": "bool hasCycle(ListNode* head) {\n    // your code here\n    return false;\n}"
  },
   "examples": [
      {
        "input": "[3,2,0,-4]",
        "output": "true",
        "explanation": "There is a cycle linking back to index 1."
      },
      {
        "input": "[1]",
        "output": "false",
        "explanation": "Single node with no cycle."
      }
    ],
    "constraints": [
      "The number of nodes in the list is in the range [0, 10^4]",
      "-10^5 <= Node.val <= 10^5"
    ],
  "testCases": [
    { "input": "[3,2,0,-4]", "expectedOutputs": ["true"] },
    { "input": "[1,2]", "expectedOutputs": ["true"] },
    { "input": "[1]", "expectedOutputs": ["false"] },
    { "input": "[]", "expectedOutputs": ["false"] },
    { "input": "[1,2,3,4,5]", "expectedOutputs": ["false"] },
    { "input": "[1,2,3,4,2]", "expectedOutputs": ["true"] },
    { "input": "[1,2,3,4,0]", "expectedOutputs": ["true"] },
    { "input": "[1]", "expectedOutputs": ["false"] },
    { "input": "[1,2,1]", "expectedOutputs": ["true"] },
    { "input": "[1,2,3]", "expectedOutputs": ["false"] }
  ]
},
{
  "id": 14,
  "title": "Number of Provinces",
  "category": "graph",
  "difficulty": "medium",
  "description": "There are n cities. Some of them are connected, while some are not. A province is a group of directly or indirectly connected cities. Return the number of provinces.",
  "functionSignature": {
    "javascript": "function findCircleNum(isConnected) {\n  // your code here\n}",
    "python": "def find_circle_num(is_connected):\n    # your code here\n    pass",
    "java": "public int findCircleNum(int[][] isConnected) {\n    // your code here\n    return 0;\n}",
    "cpp": "int findCircleNum(vector<vector<int>>& isConnected) {\n    // your code here\n    return 0;\n}"
  },
    "examples": [
      {
        "input": "[[1,1,0],[1,1,0],[0,0,1]]",
        "output": "2",
        "explanation": "There are 2 separate provinces."
      },
      {
        "input": "[[1,0,0],[0,1,0],[0,0,1]]",
        "output": "3",
        "explanation": "All nodes are isolated."
      }
    ],
    "constraints": [
      "1 <= isConnected.length <= 200",
      "isConnected[i][j] is 1 or 0",
      "isConnected[i][i] == 1"
    ],
  "testCases": [
    { "input": "[[1,1,0],[1,1,0],[0,0,1]]", "expectedOutputs": ["2"] },
    { "input": "[[1,0,0],[0,1,0],[0,0,1]]", "expectedOutputs": ["3"] },
    { "input": "[[1,1,1],[1,1,1],[1,1,1]]", "expectedOutputs": ["1"] },
    { "input": "[[1]]", "expectedOutputs": ["1"] },
    { "input": "[[1,0],[0,1]]", "expectedOutputs": ["2"] },
    { "input": "[[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]]", "expectedOutputs": ["1"] },
    { "input": "[[1,0,0,1],[0,1,1,0],[0,1,1,1],[1,0,1,1]]", "expectedOutputs": ["1"] },
    { "input": "[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]", "expectedOutputs": ["4"] },
    { "input": "[[1,1,0,0],[1,1,0,0],[0,0,1,1],[0,0,1,1]]", "expectedOutputs": ["2"] },
    { "input": "[[1,1],[1,1]]", "expectedOutputs": ["1"] }
  ]
},
{
  "id": 15,
  "title": "Longest Increasing Subsequence",
  "category": "arrays",
  "difficulty": "medium",
  "description": "Given an integer array nums, return the length of the longest strictly increasing subsequence.",
  "functionSignature": {
    "javascript": "function lengthOfLIS(nums) {\n  // your code here\n}",
    "python": "def length_of_lis(nums):\n    # your code here\n    pass",
    "java": "public int lengthOfLIS(int[] nums) {\n    // your code here\n    return 0;\n}",
    "cpp": "int lengthOfLIS(vector<int>& nums) {\n    // your code here\n    return 0;\n}"
  },
    "examples": [
      {
        "input": "[10,9,2,5,3,7,101,18]",
        "output": "4",
        "explanation": "The LIS is [2,3,7,101]"
      },
      {
        "input": "[0,1,0,3,2,3]",
        "output": "4",
        "explanation": "The LIS is [0,1,2,3]"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 2500",
      "-10^4 <= nums[i] <= 10^4"
    ],
  "testCases": [
    { "input": "[10,9,2,5,3,7,101,18]", "expectedOutputs": ["4"] },
    { "input": "[0,1,0,3,2,3]", "expectedOutputs": ["4"] },
    { "input": "[7,7,7,7,7,7,7]", "expectedOutputs": ["1"] },
    { "input": "[4,10,4,3,8,9]", "expectedOutputs": ["3"] },
    { "input": "[1,3,6,7,9,4,10,5,6]", "expectedOutputs": ["6"] },
    { "input": "[1]", "expectedOutputs": ["1"] },
    { "input": "[1,2]", "expectedOutputs": ["2"] },
    { "input": "[2,2]", "expectedOutputs": ["1"] },
    { "input": "[3,1,2]", "expectedOutputs": ["2"] },
    { "input": "[0]", "expectedOutputs": ["1"] }
  ]
},
{
  "id": 16,
  "title": "Remove N-th Node From End of List",
  "category": "linked list",
  "difficulty": "medium",
  "description": "Given the head of a linked list, remove the n-th node from the end of the list and return its head.",
  "functionSignature": {
    "javascript": "function removeNthFromEnd(head, n) {\n  // your code here\n}",
    "python": "def remove_nth_from_end(head, n):\n    # your code here\n    pass",
    "java": "public ListNode removeNthFromEnd(ListNode head, int n) {\n    // your code here\n    return null;\n}",
    "cpp": "ListNode* removeNthFromEnd(ListNode* head, int n) {\n    // your code here\n    return nullptr;\n}"
  },
   "examples": [
      {
        "input": "[1,2,3,4,5], 2",
        "output": "[1,2,3,5]",
        "explanation": "Node 4 is removed."
      },
      {
        "input": "[1], 1",
        "output": "[]",
        "explanation": "Only node is removed."
      }
    ],
    "constraints": [
      "The number of nodes in the list is in the range [1, 10^4]",
      "0 <= Node.val <= 100",
      "1 <= n <= length of the list"
    ],
  "testCases": [
    { "input": "[1,2,3,4,5]\n2", "expectedOutputs": ["[1,2,3,5]"] },
    { "input": "[1]\n1", "expectedOutputs": ["[]"] },
    { "input": "[1,2]\n1", "expectedOutputs": ["[1]"] },
    { "input": "[1,2,3]\n3", "expectedOutputs": ["[2,3]"] },
    { "input": "[1,2,3]\n2", "expectedOutputs": ["[1,3]"] },
    { "input": "[1,2,3]\n1", "expectedOutputs": ["[1,2]"] },
    { "input": "[10,20,30,40]\n4", "expectedOutputs": ["[20,30,40]"] },
    { "input": "[1,2,3,4,5]\n5", "expectedOutputs": ["[2,3,4,5]"] },
    { "input": "[5,6,7,8,9]\n3", "expectedOutputs": ["[5,6,8,9]"] },
    { "input": "[2,4,6,8,10]\n2", "expectedOutputs": ["[2,4,6,10]"] }
  ]
},
{
  "id": 17,
  "title": "Maximum Depth of Binary Tree",
  "category": "binary tree",
  "difficulty": "easy",
  "description": "Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
  "functionSignature": {
    "javascript": "function maxDepth(root) {\n  // your code here\n}",
    "python": "def max_depth(root):\n    # your code here\n    pass",
    "java": "public int maxDepth(TreeNode root) {\n    // your code here\n    return 0;\n}",
    "cpp": "int maxDepth(TreeNode* root) {\n    // your code here\n    return 0;\n}"
  },
     "examples": [
      {
        "input": "[3,9,20,null,null,15,7]",
        "output": "3",
        "explanation": "The maximum depth is 3: 3 → 20 → 7."
      },
      {
        "input": "[1,null,2]",
        "output": "2",
        "explanation": "Depth is root and right child."
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^4]",
      "-100 <= Node.val <= 100"
    ],
  "testCases": [
    { "input": "[3,9,20,null,null,15,7]", "expectedOutputs": ["3"] },
    { "input": "[1,null,2]", "expectedOutputs": ["2"] },
    { "input": "[]", "expectedOutputs": ["0"] },
    { "input": "[0]", "expectedOutputs": ["1"] },
    { "input": "[1,2,3,4,null,null,5]", "expectedOutputs": ["3"] },
    { "input": "[1,2,null,3,null,4,null]", "expectedOutputs": ["4"] },
    { "input": "[1,2,3,4,5]", "expectedOutputs": ["3"] },
    { "input": "[1,2,3,null,null,4,5]", "expectedOutputs": ["3"] },
    { "input": "[1,2,2,3,null,null,3]", "expectedOutputs": ["3"] },
    { "input": "[1,2,3,4,5,6,7]", "expectedOutputs": ["3"] }
  ]
},
{
  "id": 18,
  "title": "Course Schedule",
  "category": "graph",
  "difficulty": "medium",
  "description": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. Some courses may have prerequisites. Return true if it is possible to finish all courses.",
  "functionSignature": {
    "javascript": "function canFinish(numCourses, prerequisites) {\n  // your code here\n}",
    "python": "def can_finish(num_courses, prerequisites):\n    # your code here\n    pass",
    "java": "public boolean canFinish(int numCourses, int[][] prerequisites) {\n    // your code here\n    return false;\n}",
    "cpp": "bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n    // your code here\n    return false;\n}"
  },
     "examples": [
      {
        "input": "2, [[1,0]]",
        "output": "true",
        "explanation": "You can finish the courses in order 0 → 1."
      },
      {
        "input": "2, [[1,0],[0,1]]",
        "output": "false",
        "explanation": "Cycle detected: 0 → 1 → 0."
      }
    ],
    "constraints": [
      "1 <= numCourses <= 2000",
      "0 <= prerequisites.length <= 5000",
      "prerequisites[i].length == 2",
      "All courses labeled from 0 to numCourses - 1"
    ],
  "testCases": [
    { "input": "2\n[[1,0]]", "expectedOutputs": ["true"] },
    { "input": "2\n[[1,0],[0,1]]", "expectedOutputs": ["false"] },
    { "input": "3\n[[0,1],[0,2],[1,2]]", "expectedOutputs": ["true"] },
    { "input": "3\n[[1,0],[2,1],[0,2]]", "expectedOutputs": ["false"] },
    { "input": "1\n[]", "expectedOutputs": ["true"] },
    { "input": "4\n[[1,0],[2,1],[3,2]]", "expectedOutputs": ["true"] },
    { "input": "3\n[[1,0],[2,1]]", "expectedOutputs": ["true"] },
    { "input": "3\n[[1,0],[0,2],[2,1]]", "expectedOutputs": ["false"] },
    { "input": "5\n[[1,4],[2,4],[3,1],[3,2]]", "expectedOutputs": ["true"] },
    { "input": "3\n[[1,0],[2,1],[1,2]]", "expectedOutputs": ["false"] }
  ]
},
{
  "id": 19,
  "title": "Product of Array Except Self",
  "category": "arrays",
  "difficulty": "medium",
  "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. Do not use division and solve it in O(n).",
  "functionSignature": {
    "javascript": "function productExceptSelf(nums) {\n  // your code here\n}",
    "python": "def product_except_self(nums):\n    # your code here\n    pass",
    "java": "public int[] productExceptSelf(int[] nums) {\n    // your code here\n    return new int[]{};\n}",
    "cpp": "vector<int> productExceptSelf(vector<int>& nums) {\n    // your code here\n    return {};\n}"
  },
     "examples": [
      {
        "input": "[1,2,3,4]",
        "output": "[24,12,8,6]",
        "explanation": "Exclude the current index when multiplying."
      },
      {
        "input": "[0,1,2,3]",
        "output": "[6,0,0,0]",
        "explanation": "Zero affects the result."
      }
    ],
    "constraints": [
      "2 <= nums.length <= 10^5",
      "-30 <= nums[i] <= 30",
      "The product of any prefix or suffix won't overflow a 32-bit integer"
    ],
  "testCases": [
    { "input": "[1,2,3,4]", "expectedOutputs": ["[24,12,8,6]"] },
    { "input": "[2,3,4,5]", "expectedOutputs": ["[60,40,30,24]"] },
    { "input": "[1,1,1,1]", "expectedOutputs": ["[1,1,1,1]"] },
    { "input": "[0,1,2,3]", "expectedOutputs": ["[6,0,0,0]"] },
    { "input": "[4,5,1,8]", "expectedOutputs": ["[40,32,160,20]"] },
    { "input": "[2,2,2,2]", "expectedOutputs": ["[8,8,8,8]"] },
    { "input": "[1,2]", "expectedOutputs": ["[2,1]"] },
    { "input": "[10,3,5]", "expectedOutputs": ["[15,50,30]"] },
    { "input": "[9,0,1]", "expectedOutputs": ["[0,9,0]"] },
    { "input": "[1,0]", "expectedOutputs": ["[0,1]"] }
  ]
},
{
  "id": 20,
  "title": "Palindrome Linked List",
  "category": "linked list",
  "difficulty": "easy",
  "description": "Given the head of a singly linked list, return true if it is a palindrome or false otherwise.",
  "functionSignature": {
    "javascript": "function isPalindrome(head) {\n  // your code here\n}",
    "python": "def is_palindrome(head):\n    # your code here\n    pass",
    "java": "public boolean isPalindrome(ListNode head) {\n    // your code here\n    return false;\n}",
    "cpp": "bool isPalindrome(ListNode* head) {\n    // your code here\n    return false;\n}"
  },
     "examples": [
      {
        "input": "[1,2,2,1]",
        "output": "true",
        "explanation": "The list is a palindrome."
      },
      {
        "input": "[1,2]",
        "output": "false",
        "explanation": "1 and 2 are different."
      }
    ],
    "constraints": [
      "The number of nodes in the list is in the range [1, 10^5]",
      "0 <= Node.val <= 9"
    ],
  "testCases": [
    { "input": "[1,2]", "expectedOutputs": ["false"] },
    { "input": "[1,2,2,1]", "expectedOutputs": ["true"] },
    { "input": "[1,2,3,2,1]", "expectedOutputs": ["true"] },
    { "input": "[1,2,3,4]", "expectedOutputs": ["false"] },
    { "input": "[1,2,1]", "expectedOutputs": ["true"] },
    { "input": "[1]", "expectedOutputs": ["true"] },
    { "input": "[1,1]", "expectedOutputs": ["true"] },
    { "input": "[1,0,1]", "expectedOutputs": ["true"] },
    { "input": "[1,2,3,3,2,1]", "expectedOutputs": ["true"] },
    { "input": "[1,2,3,4,5]", "expectedOutputs": ["false"] }
  ]
},
{
  "id": 21,
  "title": "Same Tree",
  "category": "binary tree",
  "difficulty": "easy",
  "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.",
  "functionSignature": {
    "javascript": "function isSameTree(p, q) {\n  // your code here\n}",
    "python": "def is_same_tree(p, q):\n    # your code here\n    pass",
    "java": "public boolean isSameTree(TreeNode p, TreeNode q) {\n    // your code here\n    return false;\n}",
    "cpp": "bool isSameTree(TreeNode* p, TreeNode* q) {\n    // your code here\n    return false;\n}"
  },
    "examples": [
      {
        "input": "[1,2,3], [1,2,3]",
        "output": "true",
        "explanation": "The structure and values are the same."
      },
      {
        "input": "[1,2], [1,null,2]",
        "output": "false",
        "explanation": "The trees have different structures."
      }
    ],
    "constraints": [
      "The number of nodes in both trees is in the range [0, 100]",
      "-10^4 <= Node.val <= 10^4"
    ],
  "testCases": [
    { "input": "[1,2,3]\n[1,2,3]", "expectedOutputs": ["true"] },
    { "input": "[1,2]\n[1,null,2]", "expectedOutputs": ["false"] },
    { "input": "[1,2,1]\n[1,1,2]", "expectedOutputs": ["false"] },
    { "input": "[1]\n[1]", "expectedOutputs": ["true"] },
    { "input": "[1,null,2,3]\n[1,null,2,3]", "expectedOutputs": ["true"] },
    { "input": "[1,null,2]\n[1,2]", "expectedOutputs": ["false"] },
    { "input": "[1,2,3,4]\n[1,2,3]", "expectedOutputs": ["false"] },
    { "input": "[]\n[]", "expectedOutputs": ["true"] },
    { "input": "[5,6]\n[5,6]", "expectedOutputs": ["true"] },
    { "input": "[5,6]\n[6,5]", "expectedOutputs": ["false"] }
  ]
},
{
  "id": 23,
  "title": "Merge k Sorted Lists",
  "category": "linked list",
  "difficulty": "hard",
  "description": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.",
  "functionSignature": {
    "javascript": "function mergeKLists(lists) {\n  // your code here\n}",
    "python": "def merge_k_lists(lists):\n    # your code here\n    pass",
    "java": "public ListNode mergeKLists(ListNode[] lists) {\n    // your code here\n    return null;\n}",
    "cpp": "ListNode* mergeKLists(vector<ListNode*>& lists) {\n    // your code here\n    return nullptr;\n}"
  },
      "examples": [
      {
        "input": "[[1,4,5],[1,3,4],[2,6]]",
        "output": "[1,1,2,3,4,4,5,6]",
        "explanation": "Merge all lists into one sorted list."
      },
      {
        "input": "[]",
        "output": "[]",
        "explanation": "No lists to merge."
      }
    ],
    "constraints": [
      "k == lists.length",
      "0 <= k <= 10^4",
      "0 <= lists[i].length <= 500",
      "-10^4 <= Node.val <= 10^4",
      "Lists are sorted in ascending order"
    ],
  "testCases": [
    { "input": "[[1,4,5],[1,3,4],[2,6]]", "expectedOutputs": ["[1,1,2,3,4,4,5,6]"] },
    { "input": "[]", "expectedOutputs": ["[]"] },
    { "input": "[[]]", "expectedOutputs": ["[]"] },
    { "input": "[[2,3,5],[1,2,4]]", "expectedOutputs": ["[1,2,2,3,4,5]"] },
    { "input": "[[1],[0]]", "expectedOutputs": ["[0,1]"] },
    { "input": "[[1,2,3],[4,5],[6,7,8]]", "expectedOutputs": ["[1,2,3,4,5,6,7,8]"] },
    { "input": "[[3,5,7],[0,6],[2,4,8]]", "expectedOutputs": ["[0,2,3,4,5,6,7,8]"] },
    { "input": "[[],[1]]", "expectedOutputs": ["[1]"] },
    { "input": "[[1,3],[2,4]]", "expectedOutputs": ["[1,2,3,4]"] },
    { "input": "[[1,2,3],[],[4,5,6]]", "expectedOutputs": ["[1,2,3,4,5,6]"] }
  ]
},
{
  "id": 24,
  "title": "Lowest Common Ancestor of a Binary Tree",
  "category": "binary tree",
  "difficulty": "medium",
  "description": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.",
  "functionSignature": {
    "javascript": "function lowestCommonAncestor(root, p, q) {\n  // your code here\n}",
    "python": "def lowest_common_ancestor(root, p, q):\n    # your code here\n    pass",
    "java": "public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    // your code here\n    return null;\n}",
    "cpp": "TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n    // your code here\n    return nullptr;\n}"
  },
      "examples": [
      {
        "input": "[3,5,1,6,2,0,8,null,null,7,4], 5, 1",
        "output": "3",
        "explanation": "Common ancestor of 5 and 1 is 3."
      },
      {
        "input": "[3,5,1,6,2,0,8,null,null,7,4], 5, 4",
        "output": "5",
        "explanation": "5 is ancestor of 4."
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range [2, 10^5]",
      "-10^9 <= Node.val <= 10^9",
      "All Node values are unique",
      "p and q exist in the tree"
    ],
  "testCases": [
    { "input": "[3,5,1,6,2,0,8,null,null,7,4]\n5\n1", "expectedOutputs": ["3"] },
    { "input": "[3,5,1,6,2,0,8,null,null,7,4]\n5\n4", "expectedOutputs": ["5"] },
    { "input": "[1,2]\n1\n2", "expectedOutputs": ["1"] },
    { "input": "[1,2,3]\n2\n3", "expectedOutputs": ["1"] },
    { "input": "[2,1]\n2\n1", "expectedOutputs": ["2"] },
    { "input": "[6,2,8,0,4,7,9,null,null,3,5]\n2\n8", "expectedOutputs": ["6"] },
    { "input": "[6,2,8,0,4,7,9,null,null,3,5]\n0\n5", "expectedOutputs": ["2"] },
    { "input": "[3,1,4,null,2]\n2\n3", "expectedOutputs": ["3"] },
    { "input": "[3,5,1,6,2,0,8,null,null,7,4]\n6\n4", "expectedOutputs": ["5"] },
    { "input": "[3,5,1,6,2,0,8,null,null,7,4]\n7\n8", "expectedOutputs": ["3"] }
  ]
},
{
  "id": 25,
  "title": "Find the Town Judge",
  "category": "graph",
  "difficulty": "easy",
  "description": "In a town of n people labeled from 1 to n, there is a rumor that one of these people is the town judge. If the town judge exists, then: 1. The town judge trusts nobody. 2. Everybody (except for the town judge) trusts the town judge. Return the label of the town judge if the town judge exists and can be identified, or -1 otherwise.",
  "functionSignature": {
    "javascript": "function findJudge(n, trust) {\n  // your code here\n}",
    "python": "def find_judge(n, trust):\n    # your code here\n    pass",
    "java": "public int findJudge(int n, int[][] trust) {\n    // your code here\n    return -1;\n}",
    "cpp": "int findJudge(int n, vector<vector<int>>& trust) {\n    // your code here\n    return -1;\n}"
  },
   "examples": [
      {
        "input": "2, [[1,2]]",
        "output": "2",
        "explanation": "2 is trusted by 1 and trusts no one."
      },
      {
        "input": "3, [[1,3],[2,3]]",
        "output": "3",
        "explanation": "Everyone trusts 3 except 3 themselves."
      }
    ],
    "constraints": [
      "1 <= n <= 1000",
      "0 <= trust.length <= 10^4",
      "trust[i].length == 2",
      "All trust pairs are distinct"
    ],
  "testCases": [
    { "input": "2\n[[1,2]]", "expectedOutputs": ["2"] },
    { "input": "3\n[[1,3],[2,3]]", "expectedOutputs": ["3"] },
    { "input": "3\n[[1,3],[2,3],[3,1]]", "expectedOutputs": ["-1"] },
    { "input": "1\n[]", "expectedOutputs": ["1"] },
    { "input": "3\n[[1,2],[2,3]]", "expectedOutputs": ["-1"] },
    { "input": "4\n[[1,3],[1,4],[2,3],[2,4],[4,3]]", "expectedOutputs": ["3"] },
    { "input": "2\n[[1,2],[2,1]]", "expectedOutputs": ["-1"] },
    { "input": "3\n[[1,2],[2,3]]", "expectedOutputs": ["-1"] },
    { "input": "3\n[[1,2],[2,1],[3,1]]", "expectedOutputs": ["1"] },
    { "input": "3\n[]", "expectedOutputs": ["-1"] }
  ]
},
{
  "id": 26,
  "title": "Top K Frequent Elements",
  "category": "arrays",
  "difficulty": "medium",
  "description": "Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.",
  "functionSignature": {
    "javascript": "function topKFrequent(nums, k) {\n  // your code here\n}",
    "python": "def top_k_frequent(nums, k):\n    # your code here\n    pass",
    "java": "public int[] topKFrequent(int[] nums, int k) {\n    // your code here\n    return new int[]{};\n}",
    "cpp": "vector<int> topKFrequent(vector<int>& nums, int k) {\n    // your code here\n    return {};\n}"
  },
   "examples": [
      {
        "input": "[1,1,1,2,2,3], 2",
        "output": "[1,2]",
        "explanation": "1 and 2 are the most frequent."
      },
      {
        "input": "[1], 1",
        "output": "[1]",
        "explanation": "Only one element in the array."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^5",
      "k is in the range [1, the number of unique elements]",
      "It is guaranteed that the answer is unique"
    ],
  "testCases": [
    { "input": "[1,1,1,2,2,3]\n2", "expectedOutputs": ["[1,2]", "[2,1]"] },
    { "input": "[1]\n1", "expectedOutputs": ["[1]"] },
    { "input": "[4,1,-1,2,-1,2,3]\n2", "expectedOutputs": ["[-1,2]", "[2,-1]"] },
    { "input": "[1,1,2,2,3,3,4,4]\n4", "expectedOutputs": ["[1,2,3,4]"] },
    { "input": "[5,5,5,5,6,6,7]\n2", "expectedOutputs": ["[5,6]", "[6,5]"] },
    { "input": "[1,2,3,4,5,6,7,8,9,10]\n1", "expectedOutputs": ["[1]", "[2]", "[3]", "[4]", "[5]", "[6]", "[7]", "[8]", "[9]", "[10]"] },
    { "input": "[1,1,1,2,2,3,3,3,4,4,4,4]\n1", "expectedOutputs": ["[4]"] },
    { "input": "[1,2,2,3,3,3,4,4,4,4]\n3", "expectedOutputs": ["[4,3,2]", "[4,2,3]", "[3,4,2]"] },
    { "input": "[5,5,4,4,4,6,6,6,6]\n2", "expectedOutputs": ["[6,4]", "[4,6]"] },
    { "input": "[1,1,1,1,2,3,4,5,6,7,8,9]\n1", "expectedOutputs": ["[1]"] }
  ]
},
{
  "id": 27,
  "title": "Search in Rotated Sorted Array",
  "category": "arrays",
  "difficulty": "medium",
  "description": "Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums. You must write an algorithm with O(log n) runtime complexity.",
  "functionSignature": {
    "javascript": "function search(nums, target) {\n  // your code here\n}",
    "python": "def search(nums, target):\n    # your code here\n    pass",
    "java": "public int search(int[] nums, int target) {\n    // your code here\n    return -1;\n}",
    "cpp": "int search(vector<int>& nums, int target) {\n    // your code here\n    return -1;\n}"
  },
     "examples": [
      {
        "input": "[4,5,6,7,0,1,2], 0",
        "output": "4",
        "explanation": "The pivot is at index 4 where the value is 0."
      },
      {
        "input": "[4,5,6,7,0,1,2], 3",
        "output": "-1",
        "explanation": "3 is not in the array."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 5000",
      "-10^4 <= nums[i] <= 10^4",
      "All values of nums are unique",
      "nums is sorted and then rotated"
    ],
  "testCases": [
    { "input": "[4,5,6,7,0,1,2]\n0", "expectedOutputs": ["4"] },
    { "input": "[4,5,6,7,0,1,2]\n3", "expectedOutputs": ["-1"] },
    { "input": "[1]\n0", "expectedOutputs": ["-1"] },
    { "input": "[1,3]\n3", "expectedOutputs": ["1"] },
    { "input": "[5,1,3]\n3", "expectedOutputs": ["2"] },
    { "input": "[6,7,1,2,3,4,5]\n6", "expectedOutputs": ["0"] },
    { "input": "[1,2,3,4,5,6,7]\n5", "expectedOutputs": ["4"] },
    { "input": "[1]\n1", "expectedOutputs": ["0"] },
    { "input": "[3,1]\n1", "expectedOutputs": ["1"] },
    { "input": "[2,3,4,5,6,7,8,9,1]\n9", "expectedOutputs": ["7"] }
  ]
},
{
  "id": 28,
  "title": "Pow(x, n)",
  "category": "arrays",
  "difficulty": "medium",
  "description": "Implement pow(x, n), which calculates x raised to the power n (i.e., x^n). You must not use built-in exponent functions.",
  "functionSignature": {
    "javascript": "function myPow(x, n) {\n  // your code here\n}",
    "python": "def my_pow(x, n):\n    # your code here\n    pass",
    "java": "public double myPow(double x, int n) {\n    // your code here\n    return 0.0;\n}",
    "cpp": "double myPow(double x, int n) {\n    // your code here\n    return 0.0;\n}"
  },
    "examples": [
      {
        "input": "2.00000, 10",
        "output": "1024.0",
        "explanation": "2^10 = 1024"
      },
      {
        "input": "2.00000, -2",
        "output": "0.25",
        "explanation": "2^-2 = 1 / 4 = 0.25"
      }
    ],
    "constraints": [
      "-100.0 < x < 100.0",
      "-2^31 <= n <= 2^31-1",
      "n is an integer"
    ],
  "testCases": [
    { "input": "2.00000\n10", "expectedOutputs": ["1024.0"] },
    { "input": "2.10000\n3", "expectedOutputs": ["9.261"] },
    { "input": "2.00000\n-2", "expectedOutputs": ["0.25"] },
    { "input": "1.00000\n0", "expectedOutputs": ["1.0"] },
    { "input": "0.00001\n2147483647", "expectedOutputs": ["0.0"] },
    { "input": "2.00000\n0", "expectedOutputs": ["1.0"] },
    { "input": "34.00515\n-3", "expectedOutputs": ["3e-05"] },
    { "input": "0.00001\n-2147483648", "expectedOutputs": ["Infinity"] },
    { "input": "0\n0", "expectedOutputs": ["1.0"] },
    { "input": "0.5\n3", "expectedOutputs": ["0.125"] }
  ]
},
{
  "id": 29,
  "title": "Meeting Rooms II",
  "category": "arrays",
  "difficulty": "medium",
  "description": "Given an array of meeting time intervals where intervals[i] = [start_i, end_i], return the minimum number of conference rooms required.",
  "functionSignature": {
    "javascript": "function minMeetingRooms(intervals) {\n  // your code here\n}",
    "python": "def min_meeting_rooms(intervals):\n    # your code here\n    pass",
    "java": "public int minMeetingRooms(int[][] intervals) {\n    // your code here\n    return 0;\n}",
    "cpp": "int minMeetingRooms(vector<vector<int>>& intervals) {\n    // your code here\n    return 0;\n}"
  },
     "examples": [
      {
        "input": "[[0,30],[5,10],[15,20]]",
        "output": "2",
        "explanation": "Two meetings overlap between [5,10] and [15,20]."
      },
      {
        "input": "[[7,10],[2,4]]",
        "output": "1",
        "explanation": "No overlap, so only 1 room is needed."
      }
    ],
    "constraints": [
      "1 <= intervals.length <= 10^4",
      "0 <= start_i < end_i <= 10^6"
    ],
  "testCases": [
    { "input": "[[0,30],[5,10],[15,20]]", "expectedOutputs": ["2"] },
    { "input": "[[7,10],[2,4]]", "expectedOutputs": ["1"] },
    { "input": "[[0,5],[5,10]]", "expectedOutputs": ["1"] },
    { "input": "[[1,5],[2,6],[3,7]]", "expectedOutputs": ["3"] },
    { "input": "[[9,10],[4,9],[4,17]]", "expectedOutputs": ["2"] },
    { "input": "[[0,30],[35,40],[45,50]]", "expectedOutputs": ["1"] },
    { "input": "[[0,30],[10,15],[15,20]]", "expectedOutputs": ["2"] },
    { "input": "[[1,10],[2,3],[3,4],[4,5],[6,7],[7,8]]", "expectedOutputs": ["2"] },
    { "input": "[[13,15],[1,13]]", "expectedOutputs": ["1"] },
    { "input": "[[1,3],[2,4],[3,5],[4,6]]", "expectedOutputs": ["2"] }
  ]
},

{
  "id": 30,
  "title": "Subsets",
  "category": "arrays",
  "difficulty": "medium",
  "description": "Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets.",
  "functionSignature": {
    "javascript": "function subsets(nums) {\n  // your code here\n}",
    "python": "def subsets(nums):\n    # your code here\n    pass",
    "java": "public List<List<Integer>> subsets(int[] nums) {\n    // your code here\n    return new ArrayList<>();\n}",
    "cpp": "vector<vector<int>> subsets(vector<int>& nums) {\n    // your code here\n    return {};\n}"
  },
    "examples": [
      {
        "input": "[1,2,3]",
        "output": "[[],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]]",
        "explanation": "All subsets are generated."
      },
      {
        "input": "[0]",
        "output": "[[],[0]]",
        "explanation": "Only 0 and empty set."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10",
      "-10 <= nums[i] <= 10",
      "All elements are unique"
    ],
  "testCases": [
    { "input": "[1,2,3]", "expectedOutputs": ["[[],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]]"] },
    { "input": "[0]", "expectedOutputs": ["[[],[0]]"] },
    { "input": "[1,2]", "expectedOutputs": ["[[],[1],[2],[1,2]]"] },
    { "input": "[4,5,6]", "expectedOutputs": ["[[],[4],[5],[6],[4,5],[4,6],[5,6],[4,5,6]]"] },
    { "input": "[9]", "expectedOutputs": ["[[],[9]]"] },
    { "input": "[1,3]", "expectedOutputs": ["[[],[1],[3],[1,3]]"] },
    { "input": "[5,10]", "expectedOutputs": ["[[],[5],[10],[5,10]]"] },
    { "input": "[2,4,6]", "expectedOutputs": ["[[],[2],[4],[6],[2,4],[2,6],[4,6],[2,4,6]]"] },
    { "input": "[8,9]", "expectedOutputs": ["[[],[8],[9],[8,9]]"] },
    { "input": "[1,2,3,4]", "expectedOutputs": ["[[],[1],[2],[3],[4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4],[1,2,3],[1,2,4],[1,3,4],[2,3,4],[1,2,3,4]]"] }
  ]
},
{
  "id": 31,
  "title": "Reorder List",
  "category": "linked list",
  "difficulty": "medium",
  "description": "You are given the head of a singly linked list. Reorder the list so that the nodes are in the following order: first node, last node, second node, second last node, and so on.",
  "functionSignature": {
    "javascript": "function reorderList(head) {\n  // your code here\n}",
    "python": "def reorder_list(head):\n    # your code here\n    pass",
    "java": "public void reorderList(ListNode head) {\n    // your code here\n}",
    "cpp": "void reorderList(ListNode* head) {\n    // your code here\n}"
  },
     "examples": [
      {
        "input": "[1,2,3,4]",
        "output": "[1,4,2,3]",
        "explanation": "Last inserted after first, second after second last, etc."
      },
      {
        "input": "[1,2,3,4,5]",
        "output": "[1,5,2,4,3]",
        "explanation": "Reordered from outside to center."
      }
    ],
    "constraints": [
      "The number of nodes in the list is in the range [1, 10^4]",
      "0 <= Node.val <= 1000"
    ],
  "testCases": [
    { "input": "[1,2,3,4]", "expectedOutputs": ["[1,4,2,3]"] },
    { "input": "[1,2,3,4,5]", "expectedOutputs": ["[1,5,2,4,3]"] },
    { "input": "[1,2]", "expectedOutputs": ["[1,2]"] },
    { "input": "[1]", "expectedOutputs": ["[1]"] },
    { "input": "[1,2,3]", "expectedOutputs": ["[1,3,2]"] },
    { "input": "[1,2,3,4,5,6]", "expectedOutputs": ["[1,6,2,5,3,4]"] },
    { "input": "[10,20]", "expectedOutputs": ["[10,20]"] },
    { "input": "[1,2,3,4,5,6,7]", "expectedOutputs": ["[1,7,2,6,3,5,4]"] },
    { "input": "[0,1,2,3]", "expectedOutputs": ["[0,3,1,2]"] },
    { "input": "[7]", "expectedOutputs": ["[7]"] }
  ]
},
{
  "id": 32,
  "title": "Invert Binary Tree",
  "category": "binary tree",
  "difficulty": "easy",
  "description": "Given the root of a binary tree, invert the tree, and return its root.",
  "functionSignature": {
    "javascript": "function invertTree(root) {\n  // your code here\n}",
    "python": "def invert_tree(root):\n    # your code here\n    pass",
    "java": "public TreeNode invertTree(TreeNode root) {\n    // your code here\n    return null;\n}",
    "cpp": "TreeNode* invertTree(TreeNode* root) {\n    // your code here\n    return nullptr;\n}"
  },
     "examples": [
      {
        "input": "[4,2,7,1,3,6,9]",
        "output": "[4,7,2,9,6,3,1]",
        "explanation": "All left and right subtrees are swapped recursively."
      },
      {
        "input": "[2,1,3]",
        "output": "[2,3,1]",
        "explanation": "Simple mirror swap."
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100]",
      "-100 <= Node.val <= 100"
    ],
  "testCases": [
    { "input": "[4,2,7,1,3,6,9]", "expectedOutputs": ["[4,7,2,9,6,3,1]"] },
    { "input": "[2,1,3]", "expectedOutputs": ["[2,3,1]"] },
    { "input": "[]", "expectedOutputs": ["[]"] },
    { "input": "[1]", "expectedOutputs": ["[1]"] },
    { "input": "[1,2]", "expectedOutputs": ["[1,null,2]"] },
    { "input": "[1,null,2]", "expectedOutputs": ["[1,2]"] },
    { "input": "[3,5,1]", "expectedOutputs": ["[3,1,5]"] },
    { "input": "[4,2,null,1,3]", "expectedOutputs": ["[4,null,2,null,null,3,1]"] },
    { "input": "[1,2,3,4,null,null,5]", "expectedOutputs": ["[1,3,2,5,null,null,4]"] },
    { "input": "[7,6,9,2,null,8,10]", "expectedOutputs": ["[7,9,6,10,8,null,2]"] }
  ]
},
{
  "id": 33,
  "title": "Graph Valid Tree",
  "category": "graph",
  "difficulty": "medium",
  "description": "Given n nodes labeled from 0 to n - 1 and a list of edges, determine if the edges make up a valid tree.",
  "functionSignature": {
    "javascript": "function validTree(n, edges) {\n  // your code here\n}",
    "python": "def valid_tree(n, edges):\n    # your code here\n    pass",
    "java": "public boolean validTree(int n, int[][] edges) {\n    // your code here\n    return false;\n}",
    "cpp": "bool validTree(int n, vector<vector<int>>& edges) {\n    // your code here\n    return false;\n}"
  },
     "examples": [
      {
        "input": "5, [[0,1],[0,2],[0,3],[1,4]]",
        "output": "true",
        "explanation": "No cycles and all nodes are connected."
      },
      {
        "input": "5, [[0,1],[1,2],[2,3],[1,3],[1,4]]",
        "output": "false",
        "explanation": "Cycle detected between 1,2,3."
      }
    ],
    "constraints": [
      "1 <= n <= 2000",
      "0 <= edges.length <= 5000",
      "edges[i].length == 2",
      "No duplicate edges"
    ],
  "testCases": [
    { "input": "5\n[[0,1],[0,2],[0,3],[1,4]]", "expectedOutputs": ["true"] },
    { "input": "5\n[[0,1],[1,2],[2,3],[1,3],[1,4]]", "expectedOutputs": ["false"] },
    { "input": "1\n[]", "expectedOutputs": ["true"] },
    { "input": "2\n[[1,0]]", "expectedOutputs": ["true"] },
    { "input": "2\n[]", "expectedOutputs": ["false"] },
    { "input": "4\n[[0,1],[2,3]]", "expectedOutputs": ["false"] },
    { "input": "3\n[[0,1],[1,2]]", "expectedOutputs": ["true"] },
    { "input": "3\n[[0,1],[1,2],[2,0]]", "expectedOutputs": ["false"] },
    { "input": "4\n[[0,1],[1,2],[2,3]]", "expectedOutputs": ["true"] },
    { "input": "5\n[[0,1],[1,2],[2,3],[3,4],[4,0]]", "expectedOutputs": ["false"] }
  ]
},
{
  "id": 34,
  "title": "Merge Two Sorted Lists",
  "category": "linked list",
  "difficulty": "easy",
  "description": "Merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists.",
  "functionSignature": {
    "javascript": "function mergeTwoLists(l1, l2) {\n  // your code here\n}",
    "python": "def merge_two_lists(l1, l2):\n    # your code here\n    pass",
    "java": "public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n    // your code here\n    return null;\n}",
    "cpp": "ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n    // your code here\n    return nullptr;\n}"
  },
    "examples": [
      {
        "input": "[1,2,4], [1,3,4]",
        "output": "[1,1,2,3,4,4]",
        "explanation": "Merged and sorted properly."
      },
      {
        "input": "[], [0]",
        "output": "[0]",
        "explanation": "Empty list merged with non-empty one."
      }
    ],
    "constraints": [
      "The number of nodes in both lists is in the range [0, 50]",
      "-100 <= Node.val <= 100"
    ],
  "testCases": [
    { "input": "[1,2,4]\n[1,3,4]", "expectedOutputs": ["[1,1,2,3,4,4]"] },
    { "input": "[]\n[]", "expectedOutputs": ["[]"] },
    { "input": "[]\n[0]", "expectedOutputs": ["[0]"] },
    { "input": "[5]\n[1,2,3]", "expectedOutputs": ["[1,2,3,5]"] },
    { "input": "[1,3,5]\n[2,4,6]", "expectedOutputs": ["[1,2,3,4,5,6]"] },
    { "input": "[1]\n[1]", "expectedOutputs": ["[1,1]"] },
    { "input": "[1,2,3]\n[]", "expectedOutputs": ["[1,2,3]"] },
    { "input": "[1,3,5,7]\n[2,4]", "expectedOutputs": ["[1,2,3,4,5,7]"] },
    { "input": "[10,20]\n[5,30]", "expectedOutputs": ["[5,10,20,30]"] },
    { "input": "[0,1,2]\n[3,4,5]", "expectedOutputs": ["[0,1,2,3,4,5]"] }
  ]
},
{
  "id": 35,
  "title": "Find the Duplicate Number",
  "category": "arrays",
  "difficulty": "medium",
  "description": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive, return the duplicate number. There is only one repeated number.",
  "functionSignature": {
    "javascript": "function findDuplicate(nums) {\n  // your code here\n}",
    "python": "def find_duplicate(nums):\n    # your code here\n    pass",
    "java": "public int findDuplicate(int[] nums) {\n    // your code here\n    return -1;\n}",
    "cpp": "int findDuplicate(vector<int>& nums) {\n    // your code here\n    return -1;\n}"
  },
      "examples": [
      {
        "input": "[1,3,4,2,2]",
        "output": "2",
        "explanation": "2 appears twice, rest are unique."
      },
      {
        "input": "[3,1,3,4,2]",
        "output": "3",
        "explanation": "3 appears more than once."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^5",
      "1 <= nums[i] <= n (where n = nums.length - 1)",
      "Exactly one duplicate number exists",
      "The duplicate number can appear more than once"
    ],
  "testCases": [
    { "input": "[1,3,4,2,2]", "expectedOutputs": ["2"] },
    { "input": "[3,1,3,4,2]", "expectedOutputs": ["3"] },
    { "input": "[1,1]", "expectedOutputs": ["1"] },
    { "input": "[1,1,2]", "expectedOutputs": ["1"] },
    { "input": "[2,2,2,2,2]", "expectedOutputs": ["2"] },
    { "input": "[4,3,1,4,2]", "expectedOutputs": ["4"] },
    { "input": "[5,2,5,1,3,4]", "expectedOutputs": ["5"] },
    { "input": "[6,4,3,2,1,6,5]", "expectedOutputs": ["6"] },
    { "input": "[9,7,8,9,6,4,3,2,1,5]", "expectedOutputs": ["9"] },
    { "input": "[10,9,8,7,6,5,4,3,2,1,10]", "expectedOutputs": ["10"] }
  ]
},
{
  "id": 36,
  "title": "Clone Graph",
  "category": "graph",
  "difficulty": "medium",
  "description": "Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node contains a val and a list of neighbors.",
  "functionSignature": {
    "javascript": "function cloneGraph(node) {\n  // your code here\n}",
    "python": "def clone_graph(node):\n    # your code here\n    pass",
    "java": "public Node cloneGraph(Node node) {\n    // your code here\n    return null;\n}",
    "cpp": "Node* cloneGraph(Node* node) {\n    // your code here\n    return nullptr;\n}"
  },
     "examples": [
      {
        "input": "[[2,4],[1,3],[2,4],[1,3]]",
        "output": "[[2,4],[1,3],[2,4],[1,3]]",
        "explanation": "Each node and its neighbors are cloned."
      },
      {
        "input": "[[2],[1]]",
        "output": "[[2],[1]]",
        "explanation": "Two connected nodes are cloned correctly."
      }
    ],
    "constraints": [
      "The number of nodes is in the range [0, 100]",
      "1 <= Node.val <= 100",
      "Node.val is unique",
      "No duplicate or self-edges"
    ],
  "testCases": [
    { "input": "[]", "expectedOutputs": ["[]"] },
    { "input": "[[2,4],[1,3],[2,4],[1,3]]", "expectedOutputs": ["[[2,4],[1,3],[2,4],[1,3]]"] },
    { "input": "[[2],[1]]", "expectedOutputs": ["[[2],[1]]"] },
    { "input": "[[3],[3],[1,2]]", "expectedOutputs": ["[[3],[3],[1,2]]"] },
    { "input": "[[2,3],[1,3],[1,2]]", "expectedOutputs": ["[[2,3],[1,3],[1,2]]"] },
    { "input": "[[2,3,4],[1,3],[1,2,4],[1,3]]", "expectedOutputs": ["[[2,3,4],[1,3],[1,2,4],[1,3]]"] },
    { "input": "[[2,3],[1,4],[1,4],[2,3]]", "expectedOutputs": ["[[2,3],[1,4],[1,4],[2,3]]"] },
    { "input": "[[2],[1,3],[2]]", "expectedOutputs": ["[[2],[1,3],[2]]"] },
    { "input": "[[2,4],[1,3],[2,4],[1,3]]", "expectedOutputs": ["[[2,4],[1,3],[2,4],[1,3]]"] },
    { "input": "[[2,3],[1,3],[1,2]]", "expectedOutputs": ["[[2,3],[1,3],[1,2]]"] }
  ]
},
{
  "id": 38,
  "title": "Intersection of Two Linked Lists",
  "category": "linked list",
  "difficulty": "easy",
  "description": "Given the heads of two singly linked lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection, return null.",
  "functionSignature": {
    "javascript": "function getIntersectionNode(headA, headB) {\n  // your code here\n}",
    "python": "def get_intersection_node(headA, headB):\n    # your code here\n    pass",
    "java": "public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n    // your code here\n    return null;\n}",
    "cpp": "ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {\n    // your code here\n    return nullptr;\n}"
  },
    "examples": [
      {
        "input": "[4,1,8,4,5], [5,6,1,8,4,5]",
        "output": "8",
        "explanation": "Lists intersect at node with value 8."
      },
      {
        "input": "[2,6,4], [1,5]",
        "output": "null",
        "explanation": "No intersection."
      }
    ],
    "constraints": [
      "The number of nodes in both lists is in the range [0, 10^4]",
      "1 <= Node.val <= 10^5",
      "No cycles in either list",
      "Lists may or may not intersect"
    ],
  "testCases": [
    { "input": "[4,1,8,4,5]\n[5,6,1,8,4,5]", "expectedOutputs": ["8"] },
    { "input": "[1,9,1,2,4]\n[3,2,4]", "expectedOutputs": ["2"] },
    { "input": "[2,6,4]\n[1,5]", "expectedOutputs": ["null"] },
    { "input": "[1]\n[1]", "expectedOutputs": ["1"] },
    { "input": "[3,7,8,10]\n[99,1,8,10]", "expectedOutputs": ["8"] },
    { "input": "[1,2,3]\n[4,5,6]", "expectedOutputs": ["null"] },
    { "input": "[5,6,7,8,9]\n[0,1,2,3,4,8,9]", "expectedOutputs": ["8"] },
    { "input": "[1,2,3,4]\n[6,7,4]", "expectedOutputs": ["4"] },
    { "input": "[2]\n[3]", "expectedOutputs": ["null"] },
    { "input": "[1,2,3]\n[1,2,3]", "expectedOutputs": ["1"] }
  ]
},
{
  "id": 39,
  "title": "Lowest Common Ancestor of a Binary Tree",
  "category": "binary tree",
  "difficulty": "medium",
  "description": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.",
  "functionSignature": {
    "javascript": "function lowestCommonAncestor(root, p, q) {\n  // your code here\n}",
    "python": "def lowest_common_ancestor(root, p, q):\n    # your code here\n    pass",
    "java": "public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n    // your code here\n    return null;\n}",
    "cpp": "TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n    // your code here\n    return nullptr;\n}"
  },
      "examples": [
      {
        "input": "[3,5,1,6,2,0,8,null,null,7,4], 5, 1",
        "output": "3",
        "explanation": "LCA of 5 and 1 is 3."
      },
      {
        "input": "[3,5,1,6,2,0,8,null,null,7,4], 5, 4",
        "output": "5",
        "explanation": "Node 5 is an ancestor of node 4."
      }
    ],
    "constraints": [
      "The number of nodes is in the range [2, 10^5]",
      "-10^9 <= Node.val <= 10^9",
      "All node values are unique",
      "p and q exist in the tree"
    ],
  "testCases": [
    { "input": "[3,5,1,6,2,0,8,null,null,7,4]\n5\n1", "expectedOutputs": ["3"] },
    { "input": "[3,5,1,6,2,0,8,null,null,7,4]\n5\n4", "expectedOutputs": ["5"] },
    { "input": "[1,2]\n1\n2", "expectedOutputs": ["1"] },
    { "input": "[6,2,8,0,4,7,9,null,null,3,5]\n2\n8", "expectedOutputs": ["6"] },
    { "input": "[6,2,8,0,4,7,9,null,null,3,5]\n2\n4", "expectedOutputs": ["2"] },
    { "input": "[2,1]\n2\n1", "expectedOutputs": ["2"] },
    { "input": "[1]\n1\n1", "expectedOutputs": ["1"] },
    { "input": "[3,5,1,6,2,0,8,null,null,7,4]\n7\n4", "expectedOutputs": ["2"] },
    { "input": "[3,5,1,6,2,0,8,null,null,7,4]\n6\n4", "expectedOutputs": ["5"] },
    { "input": "[3,5,1,6,2,0,8,null,null,7,4]\n0\n8", "expectedOutputs": ["1"] }
  ]
},
{
  "id": 40,
  "title": "Course Schedule",
  "category": "graph",
  "difficulty": "medium",
  "description": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. Some courses may have prerequisites. Return true if it is possible to finish all courses.",
  "functionSignature": {
    "javascript": "function canFinish(numCourses, prerequisites) {\n  // your code here\n}",
    "python": "def can_finish(num_courses, prerequisites):\n    # your code here\n    pass",
    "java": "public boolean canFinish(int numCourses, int[][] prerequisites) {\n    // your code here\n    return false;\n}",
    "cpp": "bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n    // your code here\n    return false;\n}"
  },
    "examples": [
      {
        "input": "2, [[1,0]]",
        "output": "true",
        "explanation": "Finish in order 0 → 1."
      },
      {
        "input": "2, [[1,0],[0,1]]",
        "output": "false",
        "explanation": "Cycle: 0 → 1 → 0."
      }
    ],
    "constraints": [
      "1 <= numCourses <= 2000",
      "0 <= prerequisites.length <= 5000",
      "prerequisites[i].length == 2",
      "Courses are labeled from 0 to numCourses - 1"
    ],
  "testCases": [
    { "input": "2\n[[1,0]]", "expectedOutputs": ["true"] },
    { "input": "2\n[[1,0],[0,1]]", "expectedOutputs": ["false"] },
    { "input": "4\n[[1,0],[2,1],[3,2]]", "expectedOutputs": ["true"] },
    { "input": "3\n[[0,1],[1,2],[2,0]]", "expectedOutputs": ["false"] },
    { "input": "5\n[]", "expectedOutputs": ["true"] },
    { "input": "1\n[]", "expectedOutputs": ["true"] },
    { "input": "3\n[[1,0],[2,1]]", "expectedOutputs": ["true"] },
    { "input": "3\n[[0,1],[1,2],[2,1]]", "expectedOutputs": ["false"] },
    { "input": "6\n[[1,0],[2,1],[3,2],[1,3]]", "expectedOutputs": ["false"] },
    { "input": "3\n[[0,2],[1,2]]", "expectedOutputs": ["true"] }
  ]
},
{
  "id": 42,
  "title": "Linked List Cycle",
  "category": "linked list",
  "difficulty": "easy",
  "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it. Return true if there is a cycle, otherwise return false.",
  "functionSignature": {
    "javascript": "function hasCycle(head) {\n  // your code here\n}",
    "python": "def has_cycle(head):\n    # your code here\n    pass",
    "java": "public boolean hasCycle(ListNode head) {\n    // your code here\n    return false;\n}",
    "cpp": "bool hasCycle(ListNode *head) {\n    // your code here\n    return false;\n}"
  },
     "examples": [
      {
        "input": "[3,2,0,-4] (pos = 1)",
        "output": "true",
        "explanation": "Cycle detected at node with value 2."
      },
      {
        "input": "[1] (pos = -1)",
        "output": "false",
        "explanation": "Single node with no cycle."
      }
    ],
    "constraints": [
      "The number of nodes in the list is in the range [0, 10^4]",
      "-10^5 <= Node.val <= 10^5"
    ],
  "testCases": [
    { "input": "[3,2,0,-4] (pos = 1)", "expectedOutputs": ["true"] },
    { "input": "[1,2] (pos = 0)", "expectedOutputs": ["true"] },
    { "input": "[1] (pos = -1)", "expectedOutputs": ["false"] },
    { "input": "[]", "expectedOutputs": ["false"] },
    { "input": "[1,2,3,4] (pos = 2)", "expectedOutputs": ["true"] },
    { "input": "[1,2,3,4] (pos = -1)", "expectedOutputs": ["false"] },
    { "input": "[1,1] (pos = 1)", "expectedOutputs": ["true"] },
    { "input": "[0] (pos = 0)", "expectedOutputs": ["true"] },
    { "input": "[0] (pos = -1)", "expectedOutputs": ["false"] },
    { "input": "[1,2,3] (pos = 0)", "expectedOutputs": ["true"] }
  ]
},
{
  "id": 43,
  "title": "Maximum Depth of Binary Tree",
  "category": "binary tree",
  "difficulty": "easy",
  "description": "Given the root of a binary tree, return its maximum depth. A binary tree's depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
  "functionSignature": {
    "javascript": "function maxDepth(root) {\n  // your code here\n}",
    "python": "def max_depth(root):\n    # your code here\n    pass",
    "java": "public int maxDepth(TreeNode root) {\n    // your code here\n    return 0;\n}",
    "cpp": "int maxDepth(TreeNode* root) {\n    // your code here\n    return 0;\n}"
  },
      "examples": [
      {
        "input": "[3,9,20,null,null,15,7]",
        "output": "3",
        "explanation": "Depth is root → 20 → 7."
      },
      {
        "input": "[1,null,2]",
        "output": "2",
        "explanation": "Only right-side nodes."
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range [0, 10^4]",
      "-100 <= Node.val <= 100"
    ],
  "testCases": [
    { "input": "[3,9,20,null,null,15,7]", "expectedOutputs": ["3"] },
    { "input": "[1,null,2]", "expectedOutputs": ["2"] },
    { "input": "[]", "expectedOutputs": ["0"] },
    { "input": "[0]", "expectedOutputs": ["1"] },
    { "input": "[1,2,3,4,null,null,5]", "expectedOutputs": ["3"] },
    { "input": "[1,2,2,3,3,null,null,4,4]", "expectedOutputs": ["4"] },
    { "input": "[1,2]", "expectedOutputs": ["2"] },
    { "input": "[1,2,3,4,5,6,7]", "expectedOutputs": ["3"] },
    { "input": "[1,null,2,null,3,null,4]", "expectedOutputs": ["4"] },
    { "input": "[1,2,3,null,null,4,5]", "expectedOutputs": ["3"] }
  ]
},
{
  "id": 44,
  "title": "Redundant Connection",
  "category": "graph",
  "difficulty": "medium",
  "description": "In this problem, a tree is a connected graph with no cycles. You are given a graph that started as a tree with n nodes. An extra edge was added. Return the edge that can be removed to restore the tree property.",
  "functionSignature": {
    "javascript": "function findRedundantConnection(edges) {\n  // your code here\n}",
    "python": "def find_redundant_connection(edges):\n    # your code here\n    pass",
    "java": "public int[] findRedundantConnection(int[][] edges) {\n    // your code here\n    return new int[2];\n}",
    "cpp": "vector<int> findRedundantConnection(vector<vector<int>>& edges) {\n    // your code here\n    return {};\n}"
  },
      "examples": [
      {
        "input": "[[1,2],[1,3],[2,3]]",
        "output": "[2,3]",
        "explanation": "Edge [2,3] creates a cycle."
      },
      {
        "input": "[[1,2],[2,3],[3,4],[1,4],[1,5]]",
        "output": "[1,4]",
        "explanation": "Removing [1,4] breaks the cycle."
      }
    ],
    "constraints": [
      "n == edges.length",
      "3 <= n <= 1000",
      "edges[i].length == 2",
      "edges[i] is a valid undirected edge",
      "There are no duplicate edges",
      "The graph is connected except for the extra edge"
    ],
  "testCases": [
    { "input": "[[1,2],[1,3],[2,3]]", "expectedOutputs": ["[2,3]"] },
    { "input": "[[1,2],[2,3],[3,4],[1,4],[1,5]]", "expectedOutputs": ["[1,4]"] },
    { "input": "[[1,2],[2,3],[3,1]]", "expectedOutputs": ["[3,1]"] },
    { "input": "[[1,2],[1,3],[2,4],[1,4]]", "expectedOutputs": ["[1,4]"] },
    { "input": "[[1,5],[3,4],[3,5],[4,5],[2,4]]", "expectedOutputs": ["[4,5]"] },
    { "input": "[[1,2],[2,3],[3,4],[4,1],[1,5]]", "expectedOutputs": ["[4,1]"] },
    { "input": "[[1,2],[2,3],[3,4],[4,5],[1,5]]", "expectedOutputs": ["[1,5]"] },
    { "input": "[[1,2],[2,3],[3,4],[1,4]]", "expectedOutputs": ["[1,4]"] },
    { "input": "[[1,2],[2,3],[1,3]]", "expectedOutputs": ["[1,3]"] },
    { "input": "[[1,2],[1,3],[2,3],[3,4],[4,5]]", "expectedOutputs": ["[2,3]"] }
  ]
},
{
  "id": 45,
  "title": "Rotate Array",
  "category": "arrays",
  "difficulty": "medium",
  "description": "Given an array, rotate the array to the right by k steps, where k is non-negative.",
  "functionSignature": {
    "javascript": "function rotate(nums, k) {\n  // your code here\n}",
    "python": "def rotate(nums, k):\n    # your code here\n    pass",
    "java": "public void rotate(int[] nums, int k) {\n    // your code here\n}",
    "cpp": "void rotate(vector<int>& nums, int k) {\n    // your code here\n}"
  },
      "examples": [
      {
        "input": "[1,2,3,4,5,6,7], 3",
        "output": "[5,6,7,1,2,3,4]",
        "explanation": "Array is rotated to the right by 3 steps."
      },
      {
        "input": "[-1,-100,3,99], 2",
        "output": "[3,99,-1,-100]",
        "explanation": "Rotated twice to the right."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-2^31 <= nums[i] <= 2^31 - 1",
      "0 <= k <= 10^5"
    ],
  "testCases": [
    { "input": "[1,2,3,4,5,6,7]\n3", "expectedOutputs": ["[5,6,7,1,2,3,4]"] },
    { "input": "[-1,-100,3,99]\n2", "expectedOutputs": ["[3,99,-1,-100]"] },
    { "input": "[1,2]\n3", "expectedOutputs": ["[2,1]"] },
    { "input": "[1]\n0", "expectedOutputs": ["[1]"] },
    { "input": "[1,2,3]\n3", "expectedOutputs": ["[1,2,3]"] },
    { "input": "[1,2,3,4,5]\n1", "expectedOutputs": ["[5,1,2,3,4]"] },
    { "input": "[1,2,3,4,5,6]\n2", "expectedOutputs": ["[5,6,1,2,3,4]"] },
    { "input": "[1,2,3,4]\n5", "expectedOutputs": ["[4,1,2,3]"] },
    { "input": "[0,0,0,0]\n1", "expectedOutputs": ["[0,0,0,0]"] },
    { "input": "[1,2,3,4,5]\n0", "expectedOutputs": ["[1,2,3,4,5]"] }
  ]
}

]
